#word is   be  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word are  be  Mood=Ind|Tense=Pres|VerbForm=Fin
#word am   be  Mood=Ind|Number=Sing|Person=1|Tense=Pres|VerbForm=Fin
#word was  be  Mood=Ind|Number=Sing|Person=3|Tense=Past|VerbForm=Fin
#word were be  Mood=Ind|Tense=Past|VerbForm=Fin
#word been be  Tense=Past|VerbForm=Part
#word be   be  VerbForm=Inf
#word has  have  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word have have  VerbForm=Inf
#word had  have  Mood=Ind|Tense=Past|VerbForm=Fin
#word does  do  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word do do  VerbForm=Inf
#word did  do  Mood=Ind|Tense=Past|VerbForm=Fin
#word would would  VerbForm=Fin
#word will  will   VerbForm=Fin
#word to to _
#word that that _
#word there there _
#word not not Polarity=Neg
#word n't not Polarity=Neg
#word 's 's _
#word ' ' _
#word , , _

#lemma DEFAULT_ be cop cop head

-- The following copied from gf-ud/grammars/ShallowParseEng.labels

-- To handle "my hovercraft": i_Pron is not by default parsed as Det
#auxfun PossSgNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumSg) cn ; nmod:poss[PronType=Prs] head[Number=Sing]
#auxfun PossPlNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumPl) cn ; nmod:poss[PronType=Prs] head[Number=Plur]

-- disable plurals as mass terms
#auxfun MassNP_sg cn : CN -> NP = MassNP cn ; head[Number=Sing]
#auxfun DetCN_aPl cn : CN -> NP = DetCN aPl_Det cn ; head[Number=Plur]
#disable MassNP

#auxcat The DET
#auxfun DetCN_theSg det cn : The -> CN -> NP = DetCN the_Det cn ; det head[Number=Sing]
#auxfun DetCN_thePl det cn : The -> CN -> NP = DetCN thePl_Det cn ; det head[Number=Plur]
#disable the_Det thePl_Det

#auxfun UttImpSg_Pos vp : VP -> Utt = UttImpSg PPos (ImpVP vp) ; head[VerbForm=Inf]
#auxfun UttImpSg_Neg do neg vp : Do -> Neg -> VP -> Utt = UttImpSg PNeg (ImpVP vp) ; aux[VerbForm=Inf] advmod head[VerbForm=Inf]

#auxfun PositA_ a : A -> AP = PositA a ; head[Degree=Pos]
#auxfun UseComparA_ a : A -> AP = UseComparA a ; head[Degree=Cmp]
#auxfun SuperlA_ a : A -> AP = AdjOrd (OrdSuperl a) ; head[Degree=Sup]
#disable UseComparA OrdSuperl AdjOrd

#auxcat Comma PUNCT
#auxfun ExtAdvS_ adv comma s : Adv -> Comma -> S -> S = ExtAdvS adv s ; advmod punct head

-- the person [whose data]:RP is affected
#auxcat RelPron PRON
#auxfun FunRP_ whose data : RelPron -> CN -> RP = FunRP possess_Prep (MassNP data) IdRP ; nmod:poss[PronType=Int|Poss=Yes] head
#disable FunRP

-- the person [whose data is affected]:RCl
#auxfun PassRelCl_ affected whose_data is : V -> RP -> auxPass -> RCl = RelVP whose_data (PassV affected) ; head[Voice=Pass] nsubj:pass aux:pass
#disable PassV

-- the person [whose data is affected by the breach]:RCl
#auxfun PassRelClObl_ affected whose_data is by_breach : V -> RP -> auxPass -> Adv -> RCl = RelVP whose_data (PassVAgent affected by_breach) ; head[Voice=Pass] nsubj:pass aux:pass obl
#disable PassV

-- be notified
#auxfun PassV_ v : V -> VP = PassV v ; head[Voice=Pass]

-- TODO: can we make macros that can look below a level? would like to use PassVAgent : V -> NP -> VP directly, not have explicit prep
-- be affected by breach
#auxcat By ADP
#auxfun Agent_ the_breach by : NP -> By -> Adv = PrepNP by8agent_Prep the_breach ; head case

#auxfun PassVAgent_ affected by_the_breach : V -> Adv -> VP = PassVAgent affected by_the_breach ; head obl


-- everyone who is affected
#auxfun RelNP_ np rcl : NP -> RCl -> NP = RelNP np (UseRCl (TTAnt TPres ASimul) PPos rcl) ; head acl:relcl
