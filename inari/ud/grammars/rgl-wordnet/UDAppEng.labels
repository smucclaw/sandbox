#word is   be  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word are  be  Mood=Ind|Tense=Pres|VerbForm=Fin
#word am   be  Mood=Ind|Number=Sing|Person=1|Tense=Pres|VerbForm=Fin
#word was  be  Mood=Ind|Number=Sing|Person=3|Tense=Past|VerbForm=Fin
#word were be  Mood=Ind|Tense=Past|VerbForm=Fin
#word been be  Tense=Past|VerbForm=Part
#word be   be  VerbForm=Inf
#word has  have  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word have have  VerbForm=Inf
#word had  have  Mood=Ind|Tense=Past|VerbForm=Fin
#word does  do  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word do do  VerbForm=Inf
#word did  do  Mood=Ind|Tense=Past|VerbForm=Fin
#word would would  VerbForm=Fin
#word will  will   VerbForm=Fin
#word to to _
#word that that _
#word there there _
#word not not Polarity=Neg
#word n't not Polarity=Neg
#word 's 's _
#word ' ' _
#word , , _

#lemma DEFAULT_ be cop cop head


------------------------------------------------------------------
-- The following copied from gf-ud/grammars/ShallowParseEng.labels

-- To handle "my hovercraft": i_Pron is not by default parsed as Det
#auxfun PossSgNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumSg) cn ; nmod:poss[PronType=Prs] head[Number=Sing]
#auxfun PossPlNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumPl) cn ; nmod:poss[PronType=Prs] head[Number=Plur]
#disable PossPron

-- my 5 hovercrafts
#auxfun PossNumSgNP_ pron num cn : Pron -> Num -> CN -> NP = DetCN (DetQuant (PossPron pron) num) cn ; nmod:poss[PronType=Prs] nummod head[Number=Sing]
#auxfun PossNumPlNP_ pron num cn : Pron -> Num -> CN -> NP = DetCN (DetQuant (PossPron pron) num) cn ; nmod:poss[PronType=Prs] nummod head[Number=Plur]

-- [my mother's]:Quant
#auxcat Gen PART
#auxfun GenNP_ np gen : NP -> Gen -> Quant = GenNP np ; head case
#disable GenNP

-- [my mother's]:Quant [hovercraft]:CN
#auxfun DetCNSgNmod_ quant cn : Quant -> CN -> NP = DetCN (DetQuant quant NumSg) cn ; nmod:poss head[Number=Sing]
#auxfun DetCNPlNmod_ quant cn : Quant -> CN -> NP = DetCN (DetQuant quant NumPl) cn ; nmod:poss head[Number=Plur]


-- [my mother's]:Quant [5]:Num [hovercrafts]:CN
#auxfun DetCNNumNmod_ quant num cn : Quant -> Num -> CN -> NP = DetCN (DetQuant quant num) cn ; nmod:poss nummod head


-- #auxfun PossGenmodSgNP_ np cn : NP -> CN -> NP = GenModNP NumSg np cn ; nmod:poss head[Number=Sing]
-- #auxfun PossGenmodSgPl_ np cn : NP -> CN -> NP = GenModNP NumPl np cn ; nmod:poss head[Number=Plur]

-- disable plurals as mass terms
#auxfun MassNP_sg cn : CN -> NP = MassNP cn ; head[Number=Sing]
#auxfun DetCN_aPl cn : CN -> NP = DetCN aPl_Det cn ; head[Number=Plur]
#disable MassNP aPl_Det NumPl

#auxcat The DET
#auxfun DetCN_theSg det cn : The -> CN -> NP = DetCN the_Det cn ; det head[Number=Sing]
#auxfun DetCN_thePl det cn : The -> CN -> NP = DetCN thePl_Det cn ; det head[Number=Plur]
#disable the_Det thePl_Det

#auxfun UttImpSg_Pos vp : VP -> Utt = UttImpSg PPos (ImpVP vp) ; head[VerbForm=Inf]
#auxfun UttImpSg_Neg do neg vp : Do -> Neg -> VP -> Utt = UttImpSg PNeg (ImpVP vp) ; aux[VerbForm=Inf] advmod head[VerbForm=Inf]

#auxfun PositA_ a : A -> AP = PositA a ; head[Degree=Pos]
#auxfun UseComparA_ a : A -> AP = UseComparA a ; head[Degree=Cmp]
#auxfun SuperlA_ a : A -> AP = AdjOrd (OrdSuperl a) ; head[Degree=Sup]
#disable UseComparA OrdSuperl AdjOrd

#auxcat Comma PUNCT
#auxfun ExtAdvS_ adv comma s : Adv -> Comma -> S -> S = ExtAdvS adv s ; advmod punct head

-----------------------
-- Inari's additions --
-----------------------

#disable pot1 pot2 pot3 pot4 pot1to19

-- Some multiwords
-- ** more than **
#auxcat More ADJ
#auxcat Than ADP
#auxfun MoreThan_ more than : More -> Than -> Quant = more_than_Quant ; head[Degree=Cmp] fixed
#disable than_Prep

-- ** at least **
#auxcat At ADV
#auxfun AtLeast_ at least : At -> AdA -> AdN = at_least_AdN ; case head[Degree=Sup] -- will likely match other things — need to match with words!

-- ** 5 people **
#auxfun NumCN_ num cn : Card -> CN -> NP = DetCN (DetQuant IndefArt (NumCard num)) cn ; nummod head

-- Label variants of various
-- This relation is nmod head, and default AdNum is advmod head
#auxfun AdNumNmod_ atLeast five : AdN -> Card -> Card = AdNum atLeast five ; nmod head

-- This relation is head advmod, and default DetQuant is head nummod
#auxfun DetQuantAdvmod_ moreThan five : Quant -> Num -> Det = DetQuant moreThan five ; advmod head

-- This relation is nummod head, and default DetCN is det head
#auxfun DetCNNummod_ moreThan5 people : Det -> CN -> NP = DetCN moreThan5 people ; nummod head


-- ** acl **
-- [personal data]:CN [stored in electronic formats]:acl
#auxfun PPartCN_ cn vp : CN -> VP -> CN = AdjCN (PastPartAP vp) cn ; head acl[Tense=Past|VerbForm=Part]

-- [data breach]:CN [affecting 500 people]:acl
#auxfun PPresCN_ cn vp : CN -> VP -> CN = AdjCN (PresPartAP vp) cn ; head acl[VerbForm=Ger]

#disable PresPartAP PastPartAP


-- The construction "whose X" in the RGL is done using FunRP with possess_Prep.

-- (the person) [whose data]:RP (is affected)
#auxcat RelPron PRON
#auxfun FunRP_ whose data : RelPron -> CN -> RP = FunRP possess_Prep (MassNP data) IdRP ; nmod:poss[PronType=Int|Poss=Yes] head
#disable FunRP

-- the person [who is affected]:RS
#auxfun PassRelPres_ affected who is : V -> RP -> auxPass -> RS = UseRCl (TTAnt TPres ASimul) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux:pass[Tense=Pres]

-- … [who was affected]:RS
#auxfun PassRelPast_ affected who was : V -> RP -> auxPass -> RS = UseRCl (TTAnt TPast ASimul) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux:pass[Tense=Past]

-- … [who has been affected]:RS
#auxfun PassRelPart_ affected who has been : V -> RP -> aux -> auxPass -> RS = UseRCl (TTAnt TPres AAnter) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux[Tense=Pres] aux:pass[VerbForm=Part]

-- the data [which is stored in electronic formats]:RS
#auxfun PassRelOblPres_ stored which is in_formats : V -> RP -> auxPass -> Adv -> RS = UseRCl (TTAnt TPres ASimul) PPos (RelVP which (AdvVP (PassV stored) in_formats)) ; head[Voice=Pass] nsubj:pass aux:pass obl

-- [which has been stored in electronic formats]:RS
#auxfun PassRelOblPart_ stored which has been in_formats : V -> RP -> aux -> auxPass -> Adv -> RS = UseRCl (TTAnt TPres AAnter) PPos (RelVP which (AdvVP (PassV stored) in_formats)) ; head[Voice=Pass] nsubj:pass aux[Tense=Pres] aux:pass[VerbForm=Part] obl

-- TODO: ideally would choose this, if we saw the preposition "by" attaching to the obl. But that doesn't seem to be possible? Allowing this rule changes "stored in formats" to "stored by formats"
-- the person [whose data is affected by the breach]:RCl
--#auxfun PassRelClAgent_ affected whose_data is breach : V -> RP -> auxPass -> NP -> RCl = RelVP whose_data (PassVAgent affected breach) ; head[Voice=Pass] nsubj:pass aux:pass obl

-- be notified -- TODO: is this rule used on its own?
#auxfun PassV_ v : V -> VP = PassV v ; head[Voice=Pass]

#disable PassV

-- attach RCl to a NP
-- everyone who is affected
#auxfun RelNP_ np rs : NP -> RS -> NP = RelNP np rs ; head acl:relcl


-- ** obl **
-- stored [in electronic formats]:obl
-- default for AdvVP is head advmod, this is for head obl (i.e. Adv made by PrepNP)
#auxfun OblVP_ vp adv : VP -> Adv -> VP = AdvVP vp adv ; head obl

