#word is   be  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word are  be  Mood=Ind|Tense=Pres|VerbForm=Fin
#word am   be  Mood=Ind|Number=Sing|Person=1|Tense=Pres|VerbForm=Fin
#word was  be  Mood=Ind|Number=Sing|Person=3|Tense=Past|VerbForm=Fin
#word were be  Mood=Ind|Tense=Past|VerbForm=Fin
#word been be  Tense=Past|VerbForm=Part
#word be   be  VerbForm=Inf
#word has  have  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word have have  VerbForm=Inf
#word had  have  Mood=Ind|Tense=Past|VerbForm=Fin
#word does  do  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word do do  VerbForm=Inf
#word did  do  Mood=Ind|Tense=Past|VerbForm=Fin
#word would would  VerbForm=Fin
#word will  will   VerbForm=Fin
#word to to _
#word that that _
#word there there _
#word not not Polarity=Neg
#word n't not Polarity=Neg
#word 's 's _
#word ' ' _
#word , , _

#lemma DEFAULT_ be cop cop head


------------------------------------------------------------------
-- The following copied from gf-ud/grammars/ShallowParseEng.labels

-- To handle "my hovercraft": i_Pron is not by default parsed as Det
#auxfun PossSgNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumSg) cn ; nmod:poss[PronType=Prs] head[Number=Sing]
#auxfun PossPlNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumPl) cn ; nmod:poss[PronType=Prs] head[Number=Plur]

-- disable plurals as mass terms
#auxfun MassNP_sg cn : CN -> NP = MassNP cn ; head[Number=Sing]
#auxfun DetCN_aPl cn : CN -> NP = DetCN aPl_Det cn ; head[Number=Plur]
#disable MassNP

#auxcat The DET
#auxfun DetCN_theSg det cn : The -> CN -> NP = DetCN the_Det cn ; det head[Number=Sing]
#auxfun DetCN_thePl det cn : The -> CN -> NP = DetCN thePl_Det cn ; det head[Number=Plur]
#disable the_Det thePl_Det

#auxfun UttImpSg_Pos vp : VP -> Utt = UttImpSg PPos (ImpVP vp) ; head[VerbForm=Inf]
#auxfun UttImpSg_Neg do neg vp : Do -> Neg -> VP -> Utt = UttImpSg PNeg (ImpVP vp) ; aux[VerbForm=Inf] advmod head[VerbForm=Inf]

#auxfun PositA_ a : A -> AP = PositA a ; head[Degree=Pos]
#auxfun UseComparA_ a : A -> AP = UseComparA a ; head[Degree=Cmp]
#auxfun SuperlA_ a : A -> AP = AdjOrd (OrdSuperl a) ; head[Degree=Sup]
#disable UseComparA OrdSuperl AdjOrd

#auxcat Comma PUNCT
#auxfun ExtAdvS_ adv comma s : Adv -> Comma -> S -> S = ExtAdvS adv s ; advmod punct head

-----------------------
-- Inari's additions --
-----------------------

-- ** obl **
-- stored [in electronic formats]:obl
-- default for AdvVP is head advmod, this is for head obl (i.e. Adv made by PrepNP)
#auxfun OblVP_ vp adv : VP -> Adv -> VP = AdvVP vp adv ; head obl


-- ** acl **
-- [personal data]:CN [stored in electronic formats]:acl
#auxfun PPartCN_ cn vp : CN -> VP -> CN = AdjCN (PastPartAP vp) cn ; head acl[Tense=Past|VerbForm=Part]

-- [data breach]:CN [affecting 500 people]:acl
#auxfun PPresCN_ cn vp : CN -> VP -> CN = AdjCN (PresPartAP vp) cn ; head acl[VerbForm=Ger]

#disable PresPartAP PastPartAP


-- The construction "whose X" in the RGL is done using FunRP with possess_Prep.

-- the person [whose data]:RP is affected
#auxcat RelPron PRON
#auxfun FunRP_ whose data : RelPron -> CN -> RP = FunRP possess_Prep (MassNP data) IdRP ; nmod:poss[PronType=Int|Poss=Yes] head
#disable FunRP

-- the person [who is affected]:RCl
#auxfun PassRelCl_ affected whose_data is : V -> RP -> auxPass -> RCl = RelVP whose_data (PassV affected) ; head[Voice=Pass] nsubj:pass aux:pass

-- the data [which is stored in electronic formats]
--#auxfun PassRelClObl_ stored which is in_format : V -> RP -> auxPass -> Adv -> RCl = RelVP which (AdvVP (PassV stored) in_formats) ; head[Voice=Pass] nsubj:pass aux:pass obl

-- the person [whose data is affected by the breach]:RCl
#auxfun PassRelClAgent_ affected whose_data is breach : V -> RP -> auxPass -> NP -> RCl = RelVP whose_data (PassVAgent affected breach) ; head[Voice=Pass] nsubj:pass aux:pass obl
#disable PassV

-- be notified -- TODO: is this rule used on its own?
#auxfun PassV_ v : V -> VP = PassV v ; head[Voice=Pass]


-- everyone who is affected
#auxfun RelNP_ np rcl : NP -> RCl -> NP = RelNP np (UseRCl (TTAnt TPres ASimul) PPos rcl) ; head acl:relcl

