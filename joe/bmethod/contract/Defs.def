MACHINE Defs

DEFINITIONS
  // For convenience
  Top == TRUE = TRUE;
  Bottom == TRUE = FALSE;

  Event == struct(
    name ∈ EventName,
    is_preemptive ∈ BOOL,
    initial_timer_val ∈ ℕ₁
  );

  Effects == struct(
    // Multiplicities of the output arcs.
    trigger ∈ Actor → (RuleName ↔ Actor),
    // Multiplicities of the reset tarcs.
    interrupt ∈ Actor → (RuleName ↔ Actor)
  );

  all_possible_rule_actors ==  {rule_name, actor |
    ∃ rule. (rule ∈ Rule ∧ 
      rule'name = rule_name ∧ 
      actor ∈ rule'possible_actors
    )
  };

 event_happened(event_name, actor) ==
    ANY rule, timer_val, triggers, interrupts WHERE
      started = TRUE ∧ 
      breached_by = ∅ ∧
      // Consume the oldest token.
      // (active_rules ≠ ∅ ⇒ timer_val = min(ran(active_rules))) ∧
      rule ∈ Rule ∧
      (rule'name, actor, timer_val) ∈ active_rules ∧
      rule'event'name = event_name ∧

      // Disjunction elimination with excluded middle.
      IF rule'event'is_preemptive = TRUE THEN
        timer_val ≥ 0
      ELSE
        timer_val = 0
      END ∧

      interrupts = {rule_name, actor0, timer_val0 |
        (rule_name, actor0, timer_val0) ∈ active_rules ∧
        (rule_name, actor0) ∈ rule'on_done'interrupt(actor)
      } ∧

      triggers = {rule_name, actor0, timer_val0 |
        // Here we implicitly invoke the axiom of global choice to discharge the
        // annoying obligation to prove that the relation is actually a
        // well-defined function.
        (rule_name, actor0) ∈ rule'on_done'trigger(actor) ∧ 
        ∃ rule. (rule ∈ Rule ∧
          rule'name = rule_name ∧
          actor0 ∈ rule'possible_actors ∧
          timer_val0 = rule'event'initial_timer_val
        )
      }
    THEN
      IF rule'deontic = NCProhib THEN
        breached_by := {actor} ||
        active_rules := ∅
      ELSE
        active_rules :=
          ((active_rules \ {(rule'name, actor, timer_val)}) \ interrupts) ∪ triggers
      END
    END; 

  event_timeout(event_name, actor) ==
    ANY rule, triggers, interrupts WHERE
      started = TRUE ∧ 
      breached_by = ∅ ∧
      rule ∈ Rule ∧
      (rule'name, actor, 0) ∈ active_rules ∧
      rule'event'name = event_name ∧

      interrupts = {rule_name, actor0, timer_val0 |
        (rule_name, actor0, timer_val0) ∈ active_rules ∧
        (rule_name, actor0) ∈ rule'on_timeout'interrupt(actor)
      } ∧

      triggers = {rule_name, actor0, timer_val0 |
        (rule_name, actor0) ∈ rule'on_timeout'trigger(actor) ∧ 
        ∃ rule. (rule ∈ Rule ∧
          rule'name = rule_name ∧
          actor0 ∈ rule'possible_actors ∧
          timer_val0 = rule'event'initial_timer_val
        )
      }
    THEN
      IF rule'deontic = NCOb THEN
        breached_by := {actor} ||
        active_rules := ∅
      ELSE
        active_rules :=
          ((active_rules \ {(rule'name, actor, 0)}) \ interrupts) ∪ triggers
      END
    END

END