{- Process model for contracts inspired by Symboleo

  A contract is modelled as a distributed system with a dynamic number of nodes.
  Each deontic notion (obligation, permission, prohibition) found in a
  regulative rule gives rise to a node in the system, modelled as a
  CSP process.
  The topology of the system at runtime is dynamic in that new nodes
  corresponding to instances of obligations may be started and stopped at
  anytime.
  For communication between nodes, we use a message-passing model achieved via
  CSP channels, which are synchronized with a B machine that uses ZFC to reason
  about these messages and guard conditions.

  For our time model, we do not have any notion of a global clock.
  Instead, each node in the system carries its own local timer, which
  counts down via the discrete tic transition, until expiry.
  To synchronize these timers across all nodes, we simply synchronize all
  the tic transitions.

  TODO:
  - Read 
    https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html
  - Implement some message queue thing to handle inter-node communication.
  - Utilize the fact that the CSP we use is higher-order to abstract over
    the structure of the processes.
  - How to eliminate Zeno run like
    borrower default -> borrower default -> ...
    Can we impose a fairness constraint that forces the tic transition to run
    eventually.

  For details on CSP || B, see:
  https://prob.hhu.de/w/index.php?title=CSP-M
  https://cocotec.io/fdr/manual/cspm/processes.html

  For details on modelling the control flow induced by obligations, see:
  https://researchportal.port.ac.uk/en/publications/an-event-b-approach-to-data-sharing-agreements
  https://hal.inria.fr/inria-00525098
-}

datatype Status = breached | fulfilled

{-
  evnt is a B operation corresponding to an event.
  tic is the discrete clock tick transition, corresponding to a B operation.
  trigger and interrupt correspond to B variables.
-}
channel evnt, trigger, interrupt : Bool
channel status : Status
channel tic

Tic = tic -> Tic

{-
  An obligation gives rise to a process that dynamically instantiates obligation
  instances at runtime, when the trigger condition is met.
  Basically it models something like a timed arc petri net of the form

                + --> [event done] --> ()
                |
  [trigger] --> ()
                |
                + --> [timeout]    --> ()

  but with fancier stuff like interrupts and message passing communication
  between the nets.
  Also, the trigger condition could be a first-order formula interpreted over
  the runtime state.

  The parameter n is used to bound the max number of instances so that we
  don't end up with an infinite state space.

  Note that instead of using a global clock, we have timers local to each
  obligation instance.
  The tic transition is then synchronized across all instances of an obligation
  to force their timers to count down together.
-}
Ob(n, event_timer) =
  if n == 0
  then Tic
  else
    tic -> Ob(n, event_timer) []
    -- If the trigger condition is met, we start up a new node and continue.
    -- TODO: Keep track of PIDs of new instances.
    trigger!true -> (
      ObI(event_timer) [| {tic} |] Ob(n - 1, event_timer)
    )

{-
  Some notes:
  How to give trigger and interrupt events higher priority?
  Model scheduler mechanism in B machine?

  Such a priority relation behaves like a superiority relation in defeasible
  logic, so that the logic of guard conditions is defeasible in nature.
  What we want to say is something like

  if original_guard_condition {subjectTo: obligation_not_interrupted}
  then guard_condition

  I guess we could use the naive transformation as seen in the paper on
  automating defeasible reasoning: https://arxiv.org/pdf/2205.07335.pdf
  and squeeze in (and not ...) into every guard condition.

  Or we could just use a message queue.

  Regarding explicit time, the downside of these approaches is that we lose the
  fancy zone and region based abstractions as in timed automata that combat
  state space explosions.
  The benefit of such an approach though is that we can reason about them
  alongside other state variables.
-}
ObI(event_timer) =
  {-
    First we check if the timer has expired.
    If so, we use evnt!false to indicate that the obligation instance timed out
    and the event didn't occur in time.
  -}
  if event_timer == 0
  then evnt!false -> status!breached -> Tic
  else
    {-
      If the timer is still running, we check if the obligation has been
      interrupted.
      If no, we allow for either the event to occur or the timer to countdown.
    -}
    interrupt!false -> (
      evnt!true -> status!fulfilled -> Tic []
      tic -> ObI(event_timer - 1)
    )

MAIN = Ob(1, 3) -- [| {tic} |] Ob(1, 10)