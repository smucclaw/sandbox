-- datatype Status = breached | fulfilled
datatype Actor = org | indiv | pdpc

datatype RuleName =
  Assessment | NotifyPdpc | NotifyIndiv | ProhibitNotifyIndiv

channel trigger_rule : RuleName.Actor
channel interrupt_rule : RuleName

channel assess, notify_pdpc, notify_indiv, prohibit_notify_indiv : Bool.Actor

channel status : RuleName.Actor
channel tic

Tic = tic -> Tic

-- Unfortunately, currying doesn't work properly but at least nested lambdas do.
Rule(BreachedOrFulfilled) = \ rule_name, evnt, evnt_timer @
  let
    -- RuleI stands for rule instance.
    RuleI(actor, evnt_timer) =
      if evnt_timer < 0 then
        evnt!false!actor -> BreachedOrFulfilled(false)
      else
        evnt!true!actor -> BreachedOrFulfilled(true) []
        tic -> RuleI(actor, evnt_timer - 1)

    -- Auxiliary helper for recursion.
    -- We ignore the notion of perdurance for now.
    Go =
      tic -> Go []
      trigger_rule!rule_name?actor -> (
      -- When we interrupt a rule, are we interrupting existing instances, or do
      -- we also prevent all future instances from being spawned?
        RuleI(actor, evnt_timer) /\ interrupt_rule!rule_name -> Tic
      ) -- [| {tic} |] Go
  within
    Go 

-- Non-compensable obligations and prohibitions.
ObProhib(Hence, Lest) =
  Rule(\ is_done @ if is_done then Hence else Lest)

-- We treat Tic ~ Fulfilled and STOP (aka deadlock) ~ Breached
Ob = ObProhib(Tic, STOP)
Prohib = ObProhib(STOP, Tic)

-- Permissions and compensable obligations and prohibitions.
Perm = Rule(\ _ @ Tic)

MAIN =
  let
    Procs = {
      Tic,
      Ob(Assessment, assess, 30),
      Ob(NotifyPdpc, notify_pdpc, 3),
      Ob(NotifyIndiv, notify_indiv, 3),
      Perm(ProhibitNotifyIndiv, prohibit_notify_indiv, 5)
    }
  within
    [| {tic} |] P : Procs @ P