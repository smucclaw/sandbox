--- load ./verification/model-check  
load ./semantics/rewrite-trace

---(rewrite
  < 'lender : Actor | none >
  < 'borrower : Actor | none >
  < 'machineState : AbstractMachineState |
      rules : empty,
      time : 0,
      activeRules : empty >
  containsActor 'borrower
.)

---(rewrite
  transpile (
    RULE 'PayPayment
    PARTY 'borrower
    MUST DO 'pay_payment
    WITHIN 1 YEAR
    HENCE 'something
    LEST 'something_else
  )
.)

(srewrite
  start

  < 'lender : Actor | none > 
  < 'borrower : Actor | none >

  < 'machineState : AbstractMachineState |
    time : 0,
    rules : empty,
    activeRules : (
      PARTY 'borrower MUST DO 'pay_payment WITHIN 1,
      PARTY 'borrower SHANT DO 'default WITHIN 1
    ) >

  using rewriteTrace (
    ('borrower do 'default) ++
    ('borrower does 'pay_payment)
  )

---( PDPC race condition:
  action [actorName <- 'pdpc, actionName <- 'prohibit_notify_indiv] ;
  all * ;
  action [actorName <- 'org, actionName <- 'notify_indiv]

  Per the paper on the semantics of strategy language expressions
  (see proposition 5 of https://eprints.ucm.es/id/eprint/67449/1/slang.pdf),
  under some restrictions like a finite state space, such strategy exprs can be
  interpreted as omega-regular expressions, or equivalently, Buchi automata.
  In this case, the regex is equivalent to an LTL formula characterizing the PDPA
  race condition.
  Note that omega-regular expressions are equivalent to Buchi automaton, which
  are in turn strictly more expressive than LTL.
  The resulting Kripke structure is the intersection of the original Kripke
  structure and the Buchi automaton.
  With this, we can check if the original transition system satisfies the
  omega-regex by checking if the language accepted by the intersection automaton
  is empty.
  In other words, we can perform LTL model checking using omega-regexs defined
  in the strategy language.
)
.)

---(reduce
  modelCheck(none, [] Top)
.)