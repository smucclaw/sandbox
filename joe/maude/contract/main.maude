--- load ./semantics/transpiler
load ./semantics/semantics
--- load ./semantics/rewrite-trace-strat
--- load ./verification/race-cond-strat

---(rewrite
  transpile (
    RULE 'rule1
    PARTY 'party
    MUST DO 'action
    WITHIN 1 YEAR
    HENCE 'hence
    LEST 'lest,

    RULE 'rule2
    PARTY 'party
    SHANT DO 'action
    BY 10
    HENCE 'hence
    LEST 'lest,

    RULE 'rule3
    PARTY 'someone
    MAY DO 'action
    WITHIN 2 DAY
    HENCE 'hence
    LEST 'lest
  )
.)

--- (rewrite Active empty <> Active empty .)

---(rewrite
  deltaAction
  --- Collection of all rules in the contract.
  (
    RULE 'rule0 PARTY 'party SHANT DO 'action0 WITHIN 1 DAY HENCE empty LEST empty,
    RULE 'rule1 PARTY 'party MUST DO 'action1 WITHIN 1 DAY HENCE empty LEST empty
  )
  --- Current action to be performed.
  'party do 'action0
  --- Collection of currently active rule instances.
  Active (
    RULE 'rule0 PARTY 'party SHANT DO 'action0 WITHIN 1 DAY HENCE empty LEST empty,
    RULE 'rule1 PARTY 'party MUST DO 'action1 WITHIN 1 DAY HENCE empty LEST empty
  )
.)

(rewrite
  deltaTick
  --- Collection of all rules in the contract.
  (
    RULE 'rule0 PARTY 'party SHANT DO 'action0 WITHIN 2 DAY HENCE empty LEST empty,
    RULE 'rule1 PARTY 'party MUST DO 'action1 WITHIN 1 DAY HENCE empty LEST empty
  )
  --- Collection of currently active rule instances.
  Active (
    RULE 'rule0 PARTY 'party SHANT DO 'action0 WITHIN 1 DAY HENCE empty LEST empty,
    RULE 'rule1 PARTY 'party MUST DO 'action1 WITHIN 0 DAY HENCE empty LEST empty
  )
.)

eof

(rewrite
  tau

  < 'lender : Actor | none > 
  < 'borrower : Actor | none >

  < 'machineState : AbstractMachineState |
    time : 0,
    rules : empty,
    contractState : (
      RULE 'rule0 PARTY 'borrower MUST DO 'action WITHIN 1 DAY HENCE empty LEST empty,
      RULE 'rule1 PARTY 'borrower SHANT DO 'action WITHIN 1 DAY HENCE empty LEST empty
    ) >

  --- using raceCond(
  ---   RULE 'rule
  ---   PARTY 'borrower
  ---   SHANT DO 'action
  ---   WITHIN 10 DAY
  ---   HENCE 'hence
  ---   LEST 'lest
  --- )

  --- using rewriteTrace (
  ---   ('borrower do 'default) ++
  ---   tick
  --- )
.)

---( PDPA race condition:
  action [actorName <- 'pdpc, actionName <- 'prohibit_notify_indiv] ;
  all * ;
  action [actorName <- 'org, actionName <- 'notify_indiv]

  Per the paper on the semantics of strategy language expressions
  (see propositions 5 and 6 of https://eprints.ucm.es/id/eprint/67449/1/slang.pdf),
  under some restrictions like a finite state space, such strategy exprs are
  equivalent to omega-regular expressions, or equivalently, Buchi automata.
  In this case, the regex is equivalent to an LTL formula characterizing the PDPA
  race condition.
  The resulting Kripke structure is the intersection of the original Kripke
  structure and the Buchi automaton.
  With this, we can check if the original transition system satisfies the
  omega-regex by checking if the language accepted by the intersection automaton
  is empty.
  This is actually very similar to how LTL model checking works.

  Note that omega-regexs are technically incomparable to usual formulations of
  LTL because those are usually state-based, while regexes form an action-based
  logic.
  In other words, LTL lets you talk about formulae satisfied by states while
  regexes let you talk about transitions lying along traces.
  Some variants like Henessy-Milner based logics let you talk about both
  together.
)

---(reduce
  modelCheck(none, [] Top)
.)