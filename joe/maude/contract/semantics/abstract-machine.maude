---(
  A conditional rewriting rule of the form
    crl [rule] : t => t' if C1 /\ ... /\ Cn
  gives rise to an operational rule of the form
      C1 ... Cn
    ----------------
      C[t] => C[t']
  where:
    -  _ => _ denotes the (small-step) evaluation relation.
    - C[t] is the current configuration, decomposed (via E-unification) into an
      evaluation context C[.] with a hole and a proper subterm t.

      Note that E-unification is what happens when you perform unification
      modulo an equational theory E.
      Here we are performing unification modulo some equational
      axioms that says list concatenation is (A)ssociative and (C)ommutative,
      which is why this type of unification is called AC-unification.
      Indeed, one can think of finite multisets as what happens when you quotient
      out lists by equivalence relation that permutes the elements.

      One can also define additional equality axioms for configurations to perform
      model checking under view symmetry as in Lamport's paper
      https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/charme2005.pdf
      For instance, one can define an extra axiom that associates configurations
      of timed transition systems that equates them together, disregarding global time
      and timers:
        ceq {C, time} = {C', time'} if ...
      Such a naive definition messes up the ordering of events though.

  A rewriting logic theory is the logical theory resulting from combining all
  these rules together.
  The initial model of the theory is precisely the transition system whose
  small step evaluation relation is axiomatized by the rewriting theory.
  In other words, computation by way of => is equivalent to provability in the
  rewriting theory.
  Note that initiality is important here because standard compactness arguments
  will yield nonstandard models in which there are states that are not
  reachable from the initial state.

  We define an abstract machine semantics in the spirit of Krivine abstract machines.
  This can be summarized by the following diagram:
  rule set
  -- transpile --> initial abstract machine configuration
  -- evaluate via structural operational semantics --> resulting configuration 

  For this, we first define the notion of an abstract machine configuration to
  be a multiset of the following objects:
  - the rule set, ie input program
  - actors and their current states
  - currently active rule instances
  Throughout execution, we assume the rule set remains fixed, ie no
  dynamic modification.

  Next we axiomatize a structural operational semantics ala Plotkin via 2
  judgement forms.
  Essentially, an abstract machine is a timed transition system with:
  - Action transition:
    Configuration -- actor does action --> Configuration'
  - Time transition:
    Configuration -- time delay --> Configuration'

  To transpile rule sets into initial abstract machine configurations for
  execution, we axiomatize the judgement form:
    transpile ruleSet |-> configuration
  and some other auxiliary things.

  We assume that time is interpreted in some initial model (with the colimit
  obtained at omega for computability purposes) of a totally ordered
  commutative monoid M in which:
  - 0 is the <-least element.
  - + and < are primitive recursive.
)

load ../syntax/rule

fmod PRELUDE is
  protecting RULE .

  sorts Id Message Event ActiveRule .
  --- subsorts Time < Int .
  subsorts Event < Message .

  ops start : -> Event [ctor] .
  msgs _do_ _does_ _did_ : Id Id -> Event .
  msgs tick_ ticked_ : Nat -> Event .

  vars actorName actionName : Id .
  vars time : Nat .

  eq actorName do actionName = actorName did actionName .
  eq actorName did actionName = actorName does actionName .
  eq tick time = ticked time .

  op PARTY _ _ DO _ WITHIN _ : Id Deontic Id Nat -> ActiveRule [ctor] .

endfm

--- view Event from TRIV to PRE-SEMANTICS is
---   sort Elt to Event .
--- endv

--- view List`{Event`} from TRIV to LIST{Event} is
---   sort Elt to List`{Event`} .
--- endv

---(
  The denotational/model-theoretic interpretation of this module is an intial
  algebra isomorphic to that of List{Event}.
  As before, initiality is used to disregard nonstandard models.
)
fmod EVENT-TRACE is
  protecting PRELUDE .

  sorts EventTrace .
  subsorts Event < EventTrace .

  ops emptyEventTrace : -> EventTrace [ctor] .
  ops _++_ : EventTrace EventTrace -> EventTrace
    [ctor assoc id: emptyEventTrace] .
endfm

view ActiveRule from TRIV to PRELUDE is
  sort Elt to ActiveRule .
endv

view Set`{ActiveRule`} from TRIV to SET{ActiveRule} is
  sort Elt to Set`{ActiveRule`} .
endv

--- fmod ALLOWED-EVENT is
---   protecting EVENT-TRACE .

---   sorts AllowedEvent .
---   subsorts EventTrace < AllowedEvent .
---   ops allEvents : -> AllowedEvent [ctor] .
--- endfm

load full-maude

(omod ABSTRACT-MACHINE is
  protecting PRELUDE + SET{Rule} + SET{ActiveRule} + QID .

  subsorts Qid < Oid < Id .
  subsorts Message < Msg .

  class Actor .
  --- class Situation .

  class AbstractMachineState |
    rules : Set{Rule},
    time : Nat,
    activeRules : Set{ActiveRule} .

  vars actorName actionName ruleName machineState : Oid .
  vars activeRule : ActiveRule .
  vars activeRules activeRules' : Set{ActiveRule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars hence lest : Qid .
  vars time time' : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops deltaAction__ deltaTick__ :
    Event Set{ActiveRule} -> Set{ActiveRule} .

  eq deltaAction event empty = empty .

  ceq deltaAction
    event
    (PARTY actorName deontic DO actionName WITHIN time, activeRules)
  = deltaAction event activeRules
  if event := actorName did actionName .

  --- eq deltaAction event (activeRule, activeRules')
  --- = activeRule, deltaAction event activeRules' [owise].

  --- ceq deltaTime event (activeRule, activeRules')
  --- = activeRule', deltaTime event activeRules'
  --- if event := tick time
  --- /\ activeRule := PARTY actorName deontic DO actionName WITHIN time'
  --- /\ time' > time
  --- /\ true .

  crl [action] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules : (
        PARTY actorName deontic DO actionName WITHIN time,
        activeRules
      ) >
    event
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules : deltaAction event' activeRules >
    event'
  if event' := actorName did actionName .

  ops transpile_ : Set{Rule} -> Configuration .
  ops transpileAux__ : Set{Rule} Configuration -> Configuration .
  ops _containsActor_ : Configuration Oid -> Bool .

  eq transpile rules
  = transpileAux rules
    < 'machineState : AbstractMachineState |
      rules : rules,
      time : 0,
      activeRules : empty > .

  eq transpileAux empty config = start config .

  ceq transpileAux
    (
      (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        deadline
        HENCE hence
        LEST lest
      ), rules
    )
    config
  = transpileAux rules config'
  if config' := config
      if config containsActor actorName
      then none
      else < actorName : Actor | none >
      fi .

  eq (< actorName : Actor | > config) containsActor actorName = true .
  eq config containsActor actorName = false [owise] .

  --- if allowedEvents' :=
  ---   if allowedEvents == allEvents
  ---   then allEvents
  ---   else if head allowedEvents == (actorName does actionName)
  ---   then tail allowedEvents
  ---   else emptyEventList
  ---   fi fi .

  --- (
  ---   (allowedEvents == allEvents and allowedEvents' == allEvents) or
  ---   (allowedEvents == (actorName does actionName) ++ allowedEvents')
  --- )

  --- Simulation as primitive recursion on the input list of events.
  --- crl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules : activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : activeRules'' >
  --- if
  ---   < machineState : VerificationState |
  ---   >
  --- =>
  ---   <> .

  --- rl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules :
  ---       PARTY actorName deontic DO actionName WITHIN time, activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : deltaEvent (actorName did actionName) activeRules' > .

  --- crl [tick] :
  ---   < ruleName : ActiveRule | timer : currentTimer >
  --- =>
  ---   < ruleName : ActiveRule | timer : (currentTimer - timeDelta) >
  --- if timeDelta > 0 .

endom)