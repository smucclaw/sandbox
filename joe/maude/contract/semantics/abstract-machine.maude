---(
  A conditional rewriting rule of the form
    crl [rule] : t => t' if C1 /\ ... /\ Cn
  gives rise to an operational rule of the form
      C1 ... Cn
    ----------------
      C[t] => C[t']
  where:
    -  _ => _ denotes the (small-step) evaluation relation.
    - C[t] is the current configuration, decomposed (via E-unification) into an
      evaluation context C[.] with a hole and a proper subterm t.

      Note that E-unification is what happens when you perform unification
      modulo an equational theory E.
      Here we are performing unification modulo some equational
      axioms that says list concatenation is (A)ssociative and (C)ommutative,
      which is why this type of unification is called AC-unification.
      Indeed, one can think of finite multisets as what happens when you quotient
      out lists by equivalence relation that permutes the elements.

      One can also define additional equality axioms for configurations to perform
      model checking under view symmetry as in Lamport's paper
      https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/charme2005.pdf
      For instance, one can define an extra axiom that associates configurations
      of timed transition systems that equates them together, disregarding global time
      and timers:
        ceq {C, time} = {C', time'} if ...
      Such a naive definition messes up the ordering of events though.

  A rewriting logic theory is the logical theory resulting from combining all
  these rules together.
  The initial model of the theory is precisely the transition system whose
  small step evaluation relation is axiomatized by the rewriting theory.
  In other words, computation by way of => is equivalent to provability in the
  rewriting theory.
  Note that initiality is important here because standard compactness arguments
  will yield nonstandard models in which there are states that are not
  reachable from the initial state.

  For our semantics, we first define the notion of an abstract machine
  configuration to be a multiset of the following objects:
  - a list of all rules found in the program
  - actors
  - active rule instances

  Then we axiomatize a structural operational semantics ala Plotkin via 2
  judgement forms in the style of time transition systems:
  - Action transition:
    Configuration -- actor performs action --> Configuration'
  - Time transition:
    Configuration -- time delay --> Configuration'

  To transpile L4 rule sets into initial abstract machine configurations for
  execution, we axiomatize the judgement form:
    transpile ruleSet |-> configuration

  We assume that time is interpreted in some initial model (with the colimit
  obtained at omega for computability purposes) of a totally ordered
  commutative monoid M in which:
  - 0 is the <-least element.
  - + and < are primitive recursive.
)

load ../syntax/rule

fmod PRELUDE is
  protecting RULE .

  sorts Id Message Time Event ActiveRule .
  --- subsorts Time < Int .
  subsorts Event < Message .

  ops start : -> Event [ctor] .
  msgs _did_ _does_ : Id Id -> Event .

  op PARTY _ _ DO _ WITHIN _ : Id Deontic Id Nat -> ActiveRule [ctor] .

endfm

--- view Event from TRIV to PRE-SEMANTICS is
---   sort Elt to Event .
--- endv

--- view List`{Event`} from TRIV to LIST{Event} is
---   sort Elt to List`{Event`} .
--- endv

---(
  The denotational/model-theoretic interpretation of this module is an intial
  algebra isomorphic to that of List{Event}.
  As before, initiality is used to disregard nonstandard models.
)
fmod EVENT-TRACE is
  protecting PRELUDE .

  sorts EventTrace .
  subsorts Event < EventTrace .

  ops emptyEventList : -> EventTrace [ctor] . 
  ops _++_ : EventTrace EventTrace -> EventTrace [ctor assoc id: emptyEventList] .

  vars event : Event .
  vars events : EventTrace .

  ops head_ : EventTrace -> Event .
  eq head (event ++ events) = event .

  ops tail_ : EventTrace -> EventTrace .
  eq tail (event ++ events) = events .
endfm

view ActiveRule from TRIV to PRELUDE is
  sort Elt to ActiveRule .
endv

view Set`{ActiveRule`} from TRIV to SET{ActiveRule} is
  sort Elt to Set`{ActiveRule`} .
endv

--- fmod ALLOWED-EVENT is
---   protecting EVENT-TRACE .

---   sorts AllowedEvent .
---   subsorts EventTrace < AllowedEvent .
---   ops allEvents : -> AllowedEvent [ctor] .
--- endfm

load full-maude

(omod ABSTRACT-MACHINE is
  protecting PRELUDE + SET{Rule} + SET{ActiveRule} + QID .

  subsorts Qid < Oid < Id .
  subsorts Message < Msg .

  class Actor .
  --- class Situation .

  --- Inspired by Krivine abstract machines and
  --- https://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/mscs92.pdf
  class AbstractMachineState |
    rules : Set{Rule},
    time : Nat,
    activeRules : Set{ActiveRule} .

  vars actorName actionName ruleName machineState : Oid .
  vars activeRule : ActiveRule .
  vars activeRules' activeRules'' : Set{ActiveRule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars hence lest : Qid .
  vars time : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops deltaEvent__ : Event Set{ActiveRule} -> Set{ActiveRule} .
  eq deltaEvent event empty = empty .

  ceq deltaEvent
    event
    (PARTY actorName deontic DO actionName WITHIN time, activeRules')
  = deltaEvent event activeRules'
  if event := actorName did actionName .

  eq deltaEvent event (activeRule, activeRules')
  = activeRule, deltaEvent event activeRules' .

  --- ops deltaTime__ : Time Set{ActiveRule} -> Set{ActiveRule}

  crl [event] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules :
        PARTY actorName deontic DO actionName WITHIN time, activeRules' >
    event
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules : deltaEvent event' activeRules' >
    event'
  if event' := actorName did actionName .

  ops transpile_ : Set{Rule} -> Configuration .
  ops transpileAux__ : Set{Rule} Configuration -> Configuration .
  ops _containsActor_ : Configuration Oid -> Bool .

  eq transpile rules
  = transpileAux rules
    < 'machineState : AbstractMachineState |
      rules : rules,
      time : 0,
      activeRules : empty > .

  eq transpileAux empty config = start config .

  ceq transpileAux
    (
      (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        deadline
        HENCE hence
        LEST lest
      ), rules
    )
    config
  = transpileAux rules config'
  if config' := config
      if config containsActor actorName
      then none
      else < actorName : Actor | none >
      fi .

  eq (< actorName : Actor | > config) containsActor actorName = true .
  eq config containsActor actorName = false [owise] .

  --- if allowedEvents' :=
  ---   if allowedEvents == allEvents
  ---   then allEvents
  ---   else if head allowedEvents == (actorName does actionName)
  ---   then tail allowedEvents
  ---   else emptyEventList
  ---   fi fi .

  --- (
  ---   (allowedEvents == allEvents and allowedEvents' == allEvents) or
  ---   (allowedEvents == (actorName does actionName) ++ allowedEvents')
  --- )

  --- Simulation as primitive recursion on the input list of events.
  --- crl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules : activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : activeRules'' >
  --- if
  ---   < machineState : VerificationState |
  ---   >
  --- =>
  ---   <> .

  --- rl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules :
  ---       PARTY actorName deontic DO actionName WITHIN time, activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : deltaEvent (actorName did actionName) activeRules' > .

  --- crl [tick] :
  ---   < ruleName : ActiveRule | timer : currentTimer >
  --- =>
  ---   < ruleName : ActiveRule | timer : (currentTimer - timeDelta) >
  --- if timeDelta > 0 .

endom)