load ../syntax/rule

fmod PRELUDE is
  protecting RULE + SET{Qid} .

  sorts Id Message Event ActionEvent TickEvent ActiveRule .

---(
  Event is an indexed family of sorts, ie a GADT with:
  data Event :: Type -> Type where
    tau :: Event Action
    do :: Oid -> Oid -> Event Action
    tick :: Event Tick
)
  subsorts ActionEvent TickEvent < Event < Message .

  ops tau : -> ActionEvent [ctor] .
  msgs _do_ _does_ _did_ : Id Id -> ActionEvent .
  ops tick : -> TickEvent [ctor].

  vars actorName actionName : Id .

  eq actorName do actionName = actorName did actionName .
  eq actorName did actionName = actorName does actionName .

  ops PARTY__DO_WITHIN_HENCE_LEST_ :
    Id Deontic Id Nat Set{Qid} Set{Qid} -> ActiveRule [ctor] .

endfm

--- view Event from TRIV to PRE-SEMANTICS is
---   sort Elt to Event .
--- endv

--- view List`{Event`} from TRIV to LIST{Event} is
---   sort Elt to List`{Event`} .
--- endv

---(
  The denotational/model-theoretic interpretation of this module is an intial
  algebra isomorphic to that of List{Event}.
  As before, initiality is used to disregard nonstandard models.
)
fmod EVENT-TRACE is
  protecting PRELUDE .

  sorts EventTrace .
  subsorts Event < EventTrace .

  ops emptyEventTrace : -> EventTrace [ctor] .
  ops _++_ : EventTrace EventTrace -> EventTrace
    [ctor assoc id: emptyEventTrace] .
endfm

view ActiveRule from TRIV to PRELUDE is
  sort Elt to ActiveRule .
endv

view Set`{ActiveRule`} from TRIV to SET{ActiveRule} is
  sort Elt to Set`{ActiveRule`} .
endv

--- fmod ALLOWED-EVENT is
---   protecting EVENT-TRACE .

---   sorts AllowedEvent .
---   subsorts EventTrace < AllowedEvent .
---   ops allEvents : -> AllowedEvent [ctor] .
--- endfm

load full-maude

(omod CONFIG is
  protecting PRELUDE + SET{Rule} + QID + SET{Qid} .

  subsorts Qid < Oid < Id .
  subsorts Message < Msg .

  sorts ActorState ContractState .

  class Actor .

  class StatefulActor |
    state : ActorState .

  subclass StatefulActor < Actor .

---(
  data ContractState where
    Active :: Set{Rule} -> ContractState
    Breached :: Oid -> ContractState
    Fulfilled :: ContractState

  For pattern matching, we perform unification modulo an equational theory
  which axiomatizes that:
  - Active empty = Fulfilled
  - For each fixed actorName : Oid,
    (ContractState, <>, Breached actorName, Fulfilled) ~ (N, *, 1, 0).
    is a monoid with an absorbing element.

  We then use this Monoid structure to define a timed transition system,
  which we view as an automaton with states given by ContractState and
  a transition function delta.
  We consider the (free) semigroup formed by considering action and tick transitions
  together with a sequential composition operator:
  ({actorName does actionName | actorName, actionName : Oid} \/ {tick}, ;)
  We define delta as the (left) semigroup actions:
  - deltaAction : ActionEvent * ContractState -> ContractState
  - deltaTick : TickEvent * ContractState -> ContractState
  These are all defined relative to the current rule set.

  Note here that breached states, ie (Breached actorName), are invariant under
  these actions, so that a contract remains breached, with no active rules,
  regardless of what transition we take.
  On the other hand, if the contract is still in progress with some active rules,
  we use these actions and the Monoid structure to foldMap over the set of
  active rules.
  More precisely, we first map the action over each rule to obtain new contract
  states for each one of them.
  These can either be:
  - a set of rules to activate.
  - a breached state indicating the actor who breached the contract.
  Thereafter, we use the Monoid structure to combine these new contract states.
)

  --- ops Active_ : Set{Rule} -> ContractState [ctor] .
  subsorts Set{Rule} < ContractState .

  ops Breached_ : Set{Qid} -> ContractState [ctor] .
  ops Fulfilled : -> ContractState [ctor] .

  ops _<>_ : ContractState ContractState -> ContractState 
    [assoc comm id: Fulfilled] .

  vars activeRules activeRules' : Set{Rule} .
  vars actorNames actorNames' : Set{Qid} .

  eq empty = Fulfilled .

  eq activeRules <> activeRules'
  = activeRules, activeRules' .

  eq (Breached actorNames) <> activeRules
  = Breached actorNames .

  eq (Breached actorNames) <> (Breached actorNames')
  = Breached (actorNames, actorNames') .

  --- class Situation .

  class AbstractMachineState |
    rules : Set{Rule},
    time : Nat,
    --- activeRules : Set{ActiveRule},
    contractState : ContractState .

endom)