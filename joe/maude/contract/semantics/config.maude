load ../syntax/rule

fmod PRELUDE is
  protecting RULE .
  protecting SET{Qid} .

  sorts Id Message Event ActionEvent TickEvent ActiveRule .

---(
  Event is an indexed family of sorts, ie a GADT with:
  data Event :: Type -> Type where
    tau :: Event Action
    do :: Oid -> Oid -> Event Action
    tick :: Event Tick
)
  subsorts ActionEvent TickEvent < Event < Message .

  ops tau : -> ActionEvent [ctor] .
  msgs _do_ _does_ _did_ : Id Id -> ActionEvent .
  ops tick : -> TickEvent [ctor].

  vars actorName actionName : Id .

  eq actorName do actionName = actorName did actionName .
  eq actorName did actionName = actorName does actionName .

  ops PARTY__DO_WITHIN_HENCE_LEST_ :
    Id Deontic Id Nat Set{Qid} Set{Qid} -> ActiveRule [ctor] .

endfm

--- view Event from TRIV to PRE-SEMANTICS is
---   sort Elt to Event .
--- endv

--- view List`{Event`} from TRIV to LIST{Event} is
---   sort Elt to List`{Event`} .
--- endv

---(
  The denotational/model-theoretic interpretation of this module is an intial
  algebra isomorphic to that of List{Event}.
  As before, initiality is used to disregard nonstandard models.
)
fmod EVENT-TRACE is
  protecting PRELUDE .

  sorts EventTrace .
  subsorts Event < EventTrace .

  ops emptyEventTrace : -> EventTrace [ctor] .
  ops _++_ : EventTrace EventTrace -> EventTrace
    [ctor assoc id: emptyEventTrace] .
endfm

view ActiveRule from TRIV to PRELUDE is
  sort Elt to ActiveRule .
endv

view Set`{ActiveRule`} from TRIV to SET{ActiveRule} is
  sort Elt to Set`{ActiveRule`} .
endv

--- fmod ALLOWED-EVENT is
---   protecting EVENT-TRACE .

---   sorts AllowedEvent .
---   subsorts EventTrace < AllowedEvent .
---   ops allEvents : -> AllowedEvent [ctor] .
--- endfm

load full-maude

(omod CONFIG is
  protecting PRELUDE .
  protecting SET{Rule} .
  protecting QID + SET{Qid} .

  subsorts Qid < Oid < Id .
  subsorts Message < Msg .

  sorts ActorState ContractState .

  class Actor .

  --- class StatefulActor |
  ---   state : ActorState .

  --- subclass StatefulActor < Actor .

---(
  With respect to a collection of rules, we define the type of runtime contract
  configurations as an algebra (in the sense of universal algbera) over a
  signature, which as an algebraic data type in Haskell, looks like:
  data ContractState :: Type where
    Active :: Set{Rule} -> ContractState
    Breached :: Set{Actor} -> ContractState
    Fulfilled :: ContractState

  A contract state of the form:
  - (Active activeRules) represents the rules that are currently active at that
    point in the contract, along with their timer values
  - (Breached actors) represents the set of actors who breached the contract
    (ie unsuccessful termination)
  - Fulfilled indicates that there are no active rules remaining and that
    the contract has successfully terminated.

  Our algebra is the (initial aka standard) model of the equational theory
  which axiomatizes:
  - Fulfilled = Active empty
    This says that the contract is deemed to be fulfilled when there are no 
    remaining active rules.
  - (ContractState, MEET, Fulfilled) is a monoid where
    - Actors is the set of all actors.
    - MEET is the meet of the complete (prob distributive as well) lattice given
      by the linear order:
        Breached actors ⊑ contractState
        Breached actors ⊑ Active activeRules
        contractState ⊑ Fulfilled (= Active empty)

  This lattice structure is based on section 2 of Hvitved's PHD thesis on CSL:
  https://di.ku.dk/english/research/phd/phd-theses/2011/hvitved12phd.pdf
  Note that the monoidal structure:
  - is abelian and contains a zero element due to the lattice structure.
  - is important because we actually use it to do foldMap things and pattern
    matching modulo associativity, commutativity, idempotence and identity.
    This means that when we do pattern matching on this algebra,
    (f (Active activeRules MEET Fulfilled)) will unify with a term of the
    form (f (Active activeRules)).

  We use this to define a timed transition system algebraically.
  That is, we define the action of the free monoid over the events
  (ActionEvent + TickEvent) on the lattice of contract states.
  By the Yoneda embedding, each event induces a continuation with a hole of type
  ContractState:
  - deltaAction : ActionEvent * ContractState -> ContractState
  - deltaTick : TickEvent * ContractState -> ContractState
  In other words, we define the action, ie effect, of each individual event on
  the current state of the contract.
  Note that as with the runtime state of a contract, these transition relations
  are also parameterized over a given set of rules.

  The monoid structure, along with these functions are defined in such a way
  that ensures that breached and fulfilled states are invariant under any action.
  On the other hand, if the contract is still in progress with some active rules,
  we use these actions and the monoidal structure to foldMap over the set of
  active rules.
  More precisely, we first map the action over each rule to obtain new contract
  states for each one of them.
  These can either be:
  - (Active activeRules) a set of rules to activate.
  - (Breached actors) a breached state indicating the actors who breached the contract.
  Thereafter, we combine them together by taking their MEET.
)

  ops Active_ : Set{Rule} -> ContractState [ctor] .
  --- subsorts Set{Rule} < ContractState .
  --- subsorts Set{Qid} < ContractState .

  ops Breached_ : Set{Qid} -> ContractState [ctor] .
  ops Fulfilled : -> ContractState [ctor] .

  ops _MEET_ : ContractState ContractState -> ContractState
    [assoc comm idem id: Fulfilled] .

  vars activeRules activeRules' : Set{Rule} .
  vars actorNames actorNames' : Set{Qid} .

  eq Active empty = Fulfilled .

  eq Active activeRules MEET Active activeRules'
  = Active (activeRules, activeRules') .

  --- Absorption properties.
  eq Breached actorNames MEET Active activeRules = Breached actorNames .
  eq Breached actorNames MEET Breached actorNames'
  = Breached (actorNames, actorNames') .

  --- class Situation .

  class AbstractMachineState |
    rules : Set{Rule},
    time : Nat,
    --- activeRules : Set{ActiveRule},
    contractState : ContractState .

endom)