load config

(omod SEMANTICS is
  protecting CONFIG .

  vars actorName actionName ruleName machineState : Oid .
  vars hence lest : Set{Qid} .
  vars activeRule : Rule .
  vars activeRules activeRules' : Set{Rule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars actionEvent : ActionEvent .
  vars tickEvent : TickEvent .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars time time' : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops _containsRuleWithEvent_ : Set{Rule} ActionEvent -> Bool .
    
  eq
    (
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest, 
      activeRules
    )
    containsRuleWithEvent
    (actorName does actionName)
  = true .

  eq activeRules containsRuleWithEvent actionEvent = false [owise].

  --- ops _containsRuleWithZeroTimer : Set{ActiveRule} -> Bool .

  --- eq (PARTY actorName deontic DO actionName WITHIN 0, activeRules)
  ---   containsRuleWithZeroTimer
  --- = true .

  --- eq activeRules containsRuleWithZeroTimer = false [owise] .

  ops getRulesWithNames__ : Set{Rule} Set{Qid} -> Set{Rule} .

  eq getRulesWithNames rules empty = empty .

  eq getRulesWithNames
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      deadline
      HENCE hence
      LEST lest,
      rules
    )
    (ruleName, ruleNames)
  = RULE ruleName
    PARTY actorName
    deontic DO actionName
    deadline
    HENCE hence
    LEST lest,
    getRulesWithNames rules ruleNames .

  eq getRulesWithNames rules (ruleName, ruleNames)
  = getRulesWithNames rules ruleNames [owise].

  ops deltaAction___ : ActionEvent Set{Rule} ContractState -> ContractState .

  eq deltaAction actionEvent rules Fulfilled = Fulfilled .

  eq deltaAction actionEvent rules (Breached actorName) = Breached actorName .

  ceq deltaAction
    (actorName do actionName)
    rules
    (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN time DAY
      HENCE hence
      LEST empty,
      activeRules
    )
  = Breached actorName .

  ceq deltaAction
    (actorName do actionName)
    rules
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = (getRulesWithNames rules hence) <>
    (deltaAction (actorName did actionName) activeRules)
  if deontic == MUST or deontic == MAY .

  eq deltaAction
    (actorName do actionName)
    rules
    (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest, 
      activeRules
    )
  = (getRulesWithNames rules lest) <>
    (deltaAction (actorName did actionName) activeRules) .

  eq deltaAction actionEvent rules (activeRule, activeRules')
  = activeRule <> (deltaAction actionEvent activeRules') [owise].

  ops deltaTick__ : Set{Rule} ContractState -> ContractState .

  eq deltaTick rules Fulfilled = Fulfilled .

  eq deltaTick rules (Breached actorName) = Breached actorName .

  eq deltaTick
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN (s time) DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest
    ) <> (deltaTick activeRules) .

  eq deltaTick
    (
      RULE ruleName
      PARTY actorName
      MUST DO actionName
      WITHIN 0 DAY
      HENCE empty
      LEST lest,
      activeRules
    )
  = Breached actorName .

  ceq deltaTick
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN 0 DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = detaTick activeRules
  if deontic == SHANT or deontic == MAY.

---(
    there exists some active rule in machineState that
    is fulfilled/breached when the action is taken
  ----------------------------------------------------- [action]
  { actorName, machineState, ... }
  -- actorName does actionName -->
  { actorName, machineState[activeRules := activeRules \ { R \in activeRules | R mentions the event }] }
)
  rl [action] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      contractState : (
        PARTY actorName
        deontic DO actionName
        WITHIN time DAY
        HENCE hence
        LEST lest,
        activeRules
      ) >
    (actorName did actionName)
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      contractState : deltaAction (actorName did actionName) activeRules >
    (actorName did actionName) .

---(
  ----------------------------------- [tick]
  { machineState, ... }
  -- tick -->
  { machineState[activeRules := deltaTick activeRules]}

  Here deltaTick is a function that:
  - removes all active rule instances with a timer of 0
  - decrements all active rule instances with a positive timer
)
  crl [tick] :
    < machineState : AbstractMachineState |
      time : time,
      contractState : activeRules >
  =>
    < machineState : AbstractMachineState |
      time : s time,
      contractState : deltaTick activeRules >
  if activeRules =/= empty .

endom)