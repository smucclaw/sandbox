load config

(omod SEMANTICS is
  protecting CONFIG .

  subsorts Qid < Oid .

  vars actorName actionName ruleName machineState : Qid .
  vars ruleNames hence lest : Set{Qid} .
  vars activeRule : Rule .
  vars activeRules activeRules' : Set{Rule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars actionEvent : ActionEvent .
  vars tickEvent : TickEvent .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars time time' : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops _containsRuleWithEvent_ : Set{Rule} ActionEvent -> Bool .

  eq
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest, 
      activeRules
    )
    containsRuleWithEvent
    (actorName does actionName)
  = true .

  eq activeRules containsRuleWithEvent actionEvent = false [owise].

  --- ops _containsRuleWithZeroTimer : Set{ActiveRule} -> Bool .

  --- eq (PARTY actorName deontic DO actionName WITHIN 0, activeRules)
  ---   containsRuleWithZeroTimer
  --- = true .

  --- eq activeRules containsRuleWithZeroTimer = false [owise] .

  ops getRulesWithNames__ : Set{Rule} Set{Qid} -> Set{Rule} .

  eq getRulesWithNames rules empty = empty .

  eq getRulesWithNames
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      deadline
      HENCE hence
      LEST lest,
      rules
    )
    (ruleName, ruleNames)
  = RULE ruleName
    PARTY actorName
    deontic DO actionName
    deadline
    HENCE hence
    LEST lest,
    getRulesWithNames rules ruleNames .

  eq getRulesWithNames rules (ruleName, ruleNames)
  = getRulesWithNames rules ruleNames [owise].

---(
  Note:
  Observe that if we define a function say
    del1 empty = empty
    del1 (x, xs) = del xs
  we can get the infinite loop:
  del1 0 = del1 (0, 0) --> del 0 = del (0, 0) --> ...
  We need to add an additional constraint to the unification procedure that is
  performed during pattern matching.
  More precisely, we need to say that x should not be contained in xs.
)
  ops deltaAction___ : Set{Rule} ActionEvent ContractState -> ContractState .

  eq deltaAction rules actionEvent (Active empty) = Active empty .

  eq deltaAction rules actionEvent (Breached actorName) = Breached actorName .

  eq deltaAction rules
    (actorName do actionName)
    Active (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN time DAY
      HENCE hence
      LEST empty,
      activeRules
    )
  = Breached actorName .

  ceq deltaAction rules
    actionEvent
    Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = Active (getRulesWithNames rules hence) <>
    deltaAction rules actionEvent (Active activeRules)
  if actionEvent := actorName do actionName
  /\ deontic == MUST or deontic == MAY .

  ceq deltaAction rules
    actionEvent
    Active (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = Active (getRulesWithNames rules lest) <>
    deltaAction rules actionEvent (Active activeRules)
  if actionEvent := actorName do actionName
  /\ lest =/= empty .

  --- eq deltaAction rules actionEvent Active (activeRule, activeRules)
  --- = Active activeRule <> deltaAction rules actionEvent (Active activeRules) [owise] .

  --- deltaTick is still a work in progress.
  ops deltaTick__ : Set{Rule} ContractState -> ContractState .

  eq deltaTick rules (Active empty) = (Active empty) .

  eq deltaTick rules (Breached actorName) = Breached actorName .

  eq deltaTick rules
    (
      Active (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        WITHIN (s time) DAY
        HENCE hence
        LEST lest,
        activeRules
      )
    )
  = Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest
    ) <> deltaTick rules (Active activeRules) .

  eq deltaTick rules
    (
      Active (
        RULE ruleName
        PARTY actorName
        MUST DO actionName
        WITHIN 0 DAY
        HENCE empty
        LEST lest,
        activeRules
      )
    )
  = Breached actorName .

  ceq deltaTick rules
    (
      Active (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        WITHIN 0 DAY
        HENCE hence
        LEST lest,
        activeRules
      )
    )
  = deltaTick rules (Active activeRules)
  if deontic == SHANT or deontic == MAY .

---(
    there exists some active rule in machineState that
    is fulfilled/breached when the action is taken
  ----------------------------------------------------- [action]
  { actorName, machineState, ... }
  -- actorName does actionName -->
  { actorName, machineState[activeRules := activeRules \ { R \in activeRules | R mentions the event }] }
)
  rl [action] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      rules : rules,
      contractState : Active (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        WITHIN time DAY
        HENCE hence
        LEST lest,
        activeRules
      ) >
    (actorName did actionName)
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      contractState :
        deltaAction rules (actorName did actionName) (Active activeRules) >
    (actorName did actionName) .

---(
  ----------------------------------- [tick]
  { machineState, ... }
  -- tick -->
  { machineState[activeRules := deltaTick activeRules]}

  Here deltaTick is a function that:
  - removes all active rule instances with a timer of 0
  - decrements all active rule instances with a positive timer
)
  crl [tick] :
    < machineState : AbstractMachineState |
      rules : rules,
      time : time,
      contractState : Active activeRules >
  =>
    < machineState : AbstractMachineState |
      time : s time,
      contractState : deltaTick rules (Active activeRules) >
  if activeRules =/= empty .

endom)