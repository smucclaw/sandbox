load transpiler

(omod SEMANTICS is
  protecting TRANSPILER .

  subsorts Qid < Oid .

  vars actorName actionName ruleName coordinator : Qid .
  vars ruleNames hence lest actorNames : Set{Qid} .
  vars activeRule : Rule .
  vars activeRules activeRules' : Set{Rule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars actionEvent : ActionEvent .
  vars tickEvent : TickEvent .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars time time' : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops _containsRuleWithEvent_ : Set{Rule} ActionEvent -> Bool .

  eq
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest, 
      activeRules
    )
    containsRuleWithEvent
    (actorName does actionName)
  = true .

  eq activeRules containsRuleWithEvent actionEvent = false [owise].

  --- ops _containsRuleWithZeroTimer : Set{ActiveRule} -> Bool .

  --- eq (PARTY actorName deontic DO actionName WITHIN 0, activeRules)
  ---   containsRuleWithZeroTimer
  --- = true .

  --- eq activeRules containsRuleWithZeroTimer = false [owise] .

  ops getRulesWithNames__ : Set{Rule} Set{Qid} -> Set{Rule} .

  eq getRulesWithNames rules empty = empty .

  eq getRulesWithNames
    (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      deadline
      HENCE hence
      LEST lest,
      rules
    )
    (ruleName, ruleNames)
  = RULE ruleName
    PARTY actorName
    deontic DO actionName
    deadline
    HENCE hence
    LEST lest,
    getRulesWithNames rules ruleNames .

  eq getRulesWithNames rules (ruleName, ruleNames)
  = getRulesWithNames rules ruleNames [owise].

  ops deltaAction___ : Set{Rule} ActionEvent ContractState -> ContractState .

  eq deltaAction rules actionEvent Fulfilled = Fulfilled .

  eq deltaAction rules actionEvent (Breached actorNames) = Breached actorNames .

  ceq deltaAction rules
    actionEvent
    Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = Active (getRulesWithNames rules hence) ^
    deltaAction rules actionEvent (Active activeRules)
  if actionEvent := actorName do actionName
  /\ deontic == MUST or deontic == MAY .

  eq deltaAction rules
    (actorName do actionName)
    Active (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = (
    if lest == empty
    then Breached actorName
    else Active (getRulesWithNames rules lest)
    fi
  ) ^ deltaAction rules (actorName do actionName) (Active activeRules) .

  eq deltaAction rules actionEvent Active (activeRule, activeRules)
  = Active activeRule ^ deltaAction rules actionEvent (Active activeRules)
    [owise] .

  --- deltaTick is still a work in progress.
  ops deltaTick__ : Set{Rule} ContractState -> ContractState .

  eq deltaTick rules Fulfilled = Fulfilled .

  eq deltaTick rules (Breached actorName) = Breached actorName .

  eq deltaTick rules
    Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN (s time) DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN time DAY
      HENCE hence
      LEST lest
    ) ^ deltaTick rules (Active activeRules) .

  ceq deltaTick rules
    Active (
      RULE ruleName
      PARTY actorName
      deontic DO actionName
      WITHIN 0 DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = (
    if deontic == MAY or lest =/= empty
    then Active (getRulesWithNames rules lest)
    else Breached actorName
    fi
  ) ^ deltaTick rules (Active activeRules)
  if deontic == MUST or deontic == MAY .

  eq deltaTick rules
    Active (
      RULE ruleName
      PARTY actorName
      SHANT DO actionName
      WITHIN 0 DAY
      HENCE hence
      LEST lest,
      activeRules
    )
  = Active (getRulesWithNames rules hence) ^
    deltaTick rules (Active activeRules) .

---(
    there exists some active rule in coordinator that
    is fulfilled/breached when the action is taken
  ----------------------------------------------------- [action]
  { actorName, coordinator } \/ actorNames
  -- actorName does actionName -->
  { actorName, coordinator[activeRules := deltaAction activeRules] } \/ actorNames

  Here,
  - actorNames refers to the set of actor names in the abstract machine.
  - The "O[x := y]" notation means update the field x in the object/record O to y.
  - deltaAction is a function that when given a set of active rules,
    activeRules, it returns the new set of active rules, namely:
      { R \in activeRules | R does mentions the event (actorName does actionName)}
)
  rl [action] :
    < actorName : Actor | >
    < coordinator : Coordinator |
      rules : rules,
      contractState : Active (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        WITHIN time DAY
        HENCE hence
        LEST lest,
        activeRules
      ) >
    event
  =>
    < actorName : Actor | >
    < coordinator : Coordinator |
      contractState :
        deltaAction rules (actorName does actionName)
          --- Kinda annoying to have to copy and paste this whole block.
          --- Does Maude have @ as-patterns ala Haskell to alleviate this?
          Active (
            RULE ruleName
            PARTY actorName
            deontic DO actionName
            WITHIN time DAY
            HENCE hence
            LEST lest,
            activeRules
          ) >
    actorName does actionName .

---(
  ----------------------------------- [tick]
  { coordinator } \/ actorNames
  -- tick -->
  { coordinator[activeRules := deltaTick activeRules, time := time + 1] } \/ actorNames

  Here deltaTick is a function that:
  - removes all active rule instances with a timer of 0
  - decrements all active rule instances with a positive timer
)
  rl [tick] :
    < coordinator : Coordinator |
      rules : rules,
      time : time,
      contractState : Active (activeRule, activeRules) >
  =>
    < coordinator : Coordinator |
      time : time + 1,
      contractState : deltaTick rules Active (activeRule, activeRules) > .

endom)