---(
  Structural operational semantics ala Plotkin in which a configuration is a
  multiset of the following objects:
    - a list of all rules found in the program.
    - actors
    - active rule instances
    - situations that hold

  A conditional rewriting rule of the form
    crl [rule] : t => t' if C1 /\ ... /\ Cn
  gives rise to an operational rule of the form
      C1 ... Cn
    ----------------
      C[t] => C[t']
  where:
    -  _ => _ denotes the (small-step) evaluation relation.
    - C[t] is the current configuration, decomposed (via E-unification) into an
      evaluation context C[.] with a hole and a proper subterm t.

      Note that E-unification is what happens when you perform unification
      modulo an equational theory E.
      Here we are performing unification modulo some equational
      axioms that says list concatenation is (A)ssociative and (C)ommutative,
      which is why this type of unification is called AC-unification.
      Indeed, one can think of finite multisets as what happens when you quotient
      out lists by equivalence relation that permutes the elements.

      One can also define additional equality axioms for configurations to perform
      model checking under view symmetry as in Lamport's paper
      https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/charme2005.pdf
      For instance, one can define an extra axiom that associates configurations
      of timed transition systems that equates them together, disregarding global time
      and timers:
        ceq {C, time} = {C', time'} if ...
      Such a naive definition messes up the ordering of events though.

  A rewriting logic theory is the logical theory resulting from combining all
  these rules together.
  The initial model of the theory is precisely the transition system whose
  small step evaluation relation is axiomatized by the rewriting theory.
  In other words, computation by way of => is equivalent to provability in the
  rewriting theory.
  Note that initiality is important here because standard compactness arguments
  will yield nonstandard models in which there are states that are not
  reachable from the initial state.

  For our semantics, we axiomatize 2 judgement forms in the style of timed
  transition systems:
  - Action transition:
    Configuration -- actor performs action --> Configuration'
  - Time transition:
    Configuration -- time delay --> Configuration'

  We assume that time is interpreted in some initial model of a totally ordered
  commutative monoid M in which:
  - 0 is the <-least element.
  - + and < are primitive recursive.
  Note that initiality is used to discard nonstandard models that result
  from a standard Compactness argument.
)

load ../syntax/rule

fmod PRE-SEMANTICS is
  protecting RULE .

  sorts Id Message Time Event ActiveRule .
  --- subsorts Time < Int .
  subsorts Event < Message .

  ops start : -> Event [ctor] .
  msgs _did_ _does_ : Id Id -> Event .

  op PARTY _ _ DO _ WITHIN _ : Id Deontic Id Time -> ActiveRule [ctor] .

endfm

--- view Event from TRIV to PRE-SEMANTICS is
---   sort Elt to Event .
--- endv

--- view List`{Event`} from TRIV to LIST{Event} is
---   sort Elt to List`{Event`} .
--- endv

---(
  The denotational/model-theoretic interpretation of this module is an intial
  algebra isomorphic to that of List{Event}.
  As before, initiality is used to disregard nonstandard models.
)
fmod EVENT-TRACE is
  protecting PRE-SEMANTICS .

  sorts EventTrace .
  subsorts Event < EventTrace .

  ops emptyEventList : -> EventTrace [ctor] . 
  ops _++_ : EventTrace EventTrace -> EventTrace [ctor assoc id: emptyEventList] .

  vars event : Event .
  vars events : EventTrace .

  ops head_ : EventTrace -> Event .
  eq head (event ++ events) = event .

  ops tail_ : EventTrace -> EventTrace .
  eq tail (event ++ events) = events .
endfm

view ActiveRule from TRIV to PRE-SEMANTICS is
  sort Elt to ActiveRule .
endv

view Set`{ActiveRule`} from TRIV to SET{ActiveRule} is
  sort Elt to Set`{ActiveRule`} .
endv

fmod ALLOWED-EVENT is
  protecting EVENT-TRACE .

  sorts AllowedEvent .
  subsorts EventTrace < AllowedEvent .
  ops allEvents : -> AllowedEvent [ctor] .
endfm

load full-maude

(omod SEMANTICS is
  protecting PRE-SEMANTICS + ALLOWED-EVENT + SET{Rule} + SET{ActiveRule} + QID .

  subsorts Qid < Oid < Id .
  subsorts Message < Msg .

  class Actor .
  --- class Situation .

  --- Inspired by Krivine abstract machines and
  --- https://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/mscs92.pdf
  class AbstractMachineState |
    rules : Set{Rule},
    time : Time,
    activeRules : Set{ActiveRule},
    allowedEvents : AllowedEvent .

  vars actorName actionName ruleName machineState : Oid .
  vars activeRule : ActiveRule .
  vars activeRules' activeRules'' : Set{ActiveRule} .
  vars event event' : Event .
  vars events : EventTrace .
  vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars time : Time .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)
  ops deltaEvent__ : Event Set{ActiveRule} -> Set{ActiveRule} .
  eq deltaEvent event empty = empty .

  eq deltaEvent
    (actorName did actionName)
    (PARTY actorName deontic DO actionName WITHIN time, activeRules')
  = deltaEvent (actorName did actionName) activeRules' .

  eq deltaEvent event (activeRule, activeRules')
  = activeRule, deltaEvent event activeRules' .

  --- ops deltaTime__ : Time Set{ActiveRule} -> Set{ActiveRule}

---(
  --------------------------------------------------------------------------
  {< A : Actor | ... >, < R : ActiveRule | actor : A >, ... }
  -- A performs actionName -->
  {< A : Actor | ... >, ... }

  How to synchronize across all rule instances?
)
  crl [event] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      allowedEvents : allowedEvents,
      activeRules :
        (PARTY actorName deontic DO actionName WITHIN time, activeRules')
    >
    event
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      allowedEvents : allowedEvents', 
      activeRules : deltaEvent (actorName did actionName) activeRules' >
    (actorName did actionName)
  if allowedEvents' :=
    if allowedEvents == allEvents
    then allEvents
    else if head(allowedEvents) == (actorName does actionName)
    then tail(allowedEvents)
    else emptyEventList
    fi fi .

  --- (
  ---   (allowedEvents == allEvents and allowedEvents' == allEvents) or
  ---   (allowedEvents == (actorName does actionName) ++ allowedEvents')
  --- )

  --- Simulation as primitive recursion on the input list of events.
  --- crl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules : activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : activeRules'' >
  --- if
  ---   < machineState : VerificationState |
  ---   >
  --- =>
  ---   <> .

  --- rl [simulationEvent] :
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : ((actorName does actionName) ++ events'),
  ---     activeRules :
  ---       PARTY actorName deontic DO actionName WITHIN time, activeRules' >
  --- =>
  ---   < actorName : Actor | >
  ---   < machineState : SimulationState |
  ---     remainingTrace : events',
  ---     activeRules : deltaEvent (actorName did actionName) activeRules' > .

  --- crl [tick] :
  ---   < ruleName : ActiveRule | timer : currentTimer >
  --- =>
  ---   < ruleName : ActiveRule | timer : (currentTimer - timeDelta) >
  --- if timeDelta > 0 .

endom)