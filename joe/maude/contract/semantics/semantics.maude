load config

(omod SEMANTICS is
  protecting CONFIG .

  vars actorName actionName ruleName machineState hence lest : Oid .
  vars activeRule : ActiveRule .
  vars activeRules activeRules' : Set{ActiveRule} .
  vars rule : Rule .
  vars rules : Set{Rule} .
  vars config config' : Configuration .
  vars actionEvent : ActionEvent .
  vars tickEvent : TickEvent .
  vars event event' : Event .
  vars deadline : Deadline .
  --- vars events : EventTrace .
  --- vars allowedEvents allowedEvents' : AllowedEvent .
  vars deontic : Deontic .
  vars time time' : Nat .

---(
  AC-unification allows us to recurse on sets as if they were lists.

  It may be more efficient to use a balanced binary tree like finger trees or
  red black trees ala
  https://matt.might.net/papers/germane2014deletion.pdf
)

  ops _containsRuleWithEvent_ : Set{ActiveRule} ActionEvent -> Bool .
    
  eq (PARTY actorName deontic DO actionName WITHIN time, activeRules)
    containsRuleWithEvent
    (actorName does actionName)
  = true .

  eq activeRules containsRuleWithEvent actionEvent = false [owise].

  --- ops _containsRuleWithZeroTimer : Set{ActiveRule} -> Bool .

  --- eq (PARTY actorName deontic DO actionName WITHIN 0, activeRules)
  ---   containsRuleWithZeroTimer
  --- = true .

  --- eq activeRules containsRuleWithZeroTimer = false [owise] .

  ops deltaAction__ : ActionEvent Set{ActiveRule} -> Set{ActiveRule} .
  eq deltaAction actionEvent empty = empty .

  ceq deltaAction
    actionEvent
    (PARTY actorName deontic DO actionName WITHIN time, activeRules)
  = deltaAction actionEvent activeRules
  if actionEvent := actorName did actionName .

  eq deltaAction actionEvent (activeRule, activeRules')
  = activeRule, deltaAction actionEvent activeRules' [owise].

  ops deltaTick_ : Set{ActiveRule} -> Set{ActiveRule} .
  eq deltaTick empty = empty .

  eq deltaTick
    (PARTY actorName deontic DO actionName WITHIN (s time), activeRules)
  = PARTY actorName deontic DO actionName WITHIN time, deltaTick activeRules .

  eq deltaTick
    (PARTY actorName deontic DO actionName WITHIN 0, activeRules)
  = deltaTick activeRules .

---(
    there exists some active rule in machineState that
    is fulfilled/breached when the action is taken
  ----------------------------------------------------- [action]
  { actorName, machineState, ... }
  -- actorName does actionName -->
  { actorName, machineState[activeRules := activeRules \ { R \in activeRules | R mentions the event }] }
)
  crl [action] :
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules : (
        PARTY actorName deontic DO actionName WITHIN time,
        activeRules
      ) >
    event
  =>
    < actorName : Actor | >
    < machineState : AbstractMachineState |
      activeRules : deltaAction event' activeRules >
    event'
  if event' := actorName did actionName .

---(
  ----------------------------------- [tick]
  { machineState, ... }
  -- tick -->
  { machineState[activeRules := deltaTick activeRules]}

  Here deltaTick is a function that:
  - removes all active rule instances with a timer of 0
  - decrements all active rule instances with a positive timer
)
  rl [tick] :
    < machineState : AbstractMachineState |
      time : time,
      activeRules : activeRules >
  =>
    < machineState : AbstractMachineState |
      time : s time,
      activeRules : deltaTick activeRules > .

endom)