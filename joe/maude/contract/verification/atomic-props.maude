---(
  Atomic propositions for model checking.
)
load model-checker
load ../semantics/semantics

(omod ATOMIC-PROPS is
  protecting CONFIG .
  including MODEL-CHECKER + SATISFACTION . 

  subsorts Configuration < State .
  subsorts ActionEvent < Prop .

  --- ops Top : -> Prop .
  ops _allowedToDo_ : Oid Oid -> Prop .
  ops _prohibitedFromDoing_ : Oid Oid -> Prop .
  --- ops raceCond_ : ActionEvent -> Formula .

  vars config : Configuration .
  vars actorName actionName machineState ruleName : Qid .
  vars hence lest : Set{Qid} .
  vars deontic : Deontic .
  vars rules : Set{Rule} .
  vars activeRules : Set{Rule} .
  vars time : Nat .

---(
  The satisfaction relation has type
    _ |= _ : Configuration -> Prop -> 2
)
  --- eq config |= Top
  --- = true .

  eq (actorName did actionName) config |= actorName did actionName
  = true .

  ceq
    < machineState : AbstractMachineState |
      contractState : (
        RULE ruleName
        PARTY actorName
        deontic DO actionName
        WITHIN time DAY
        HENCE hence
        LEST lest,
        activeRules
      ) > config
    |= actorName allowedToDo actionName
  = true
  if deontic == MUST or deontic == MAY . 

  eq
    < machineState : AbstractMachineState |
      contractState : (
        RULE ruleName
        PARTY actorName
        SHANT DO actionName
        WITHIN time DAY
        HENCE hence
        LEST lest,
        activeRules
      ) > config
    |= actorName prohibitedFromDoing actionName
  = true .

---(
  Need to loop through all actorName and actionName in a rule set and
  construct one such formula for each pair.
  Then take conjunction over all of them.

  eq raceCond (actorName does actionName) =
    (actorName does actionName) =>
      [] ~ (actorName prohibitedFromDoing actionName) .
)

endom)