---(
  Defeasibility logic theorem prover in Maude.

  This work is largely based on Guido's paper:
  https://arxiv.org/pdf/cs/0511055.pdf

  We encode the endofunctor on page 10 into a transition system which performs
  the same transfinite fixpoint iteration procedure.
  With this, we use reachability analysis and LTL model checking to check
  the provability of formulae in defeasible theories.
)

sload model-checker

fmod LITERALS is
  pr QID .
  pr BOOL .

  sorts Literal Literals .
  subsorts Qid < Literal < Literals .

  ops not_ : Qid -> Literal [ctor] .
  ops ~_ : Literal -> Literal .

  --- ops Literal < Bool .

  ops emptyLiterals : -> Literals [ctor] .
  ops _#_ : Literals Literals -> Literals
    [ctor assoc comm id: emptyLiterals] .
 
  vars q : Literal .
  vars atom : Qid .
  vars literals : Literals .

  eq ~ atom = not atom .
  eq ~ (not atom) = atom .

  ops _isLiteralOfAtom_ : Literal Qid -> Bool .
  eq q isLiteralOfAtom atom = q == atom or ~ q == atom .

  eq literals # literals = literals .

  ops _elemOf_ _notElemOf_ : Literal Literals -> Bool .

  eq q elemOf (q # literals) = true .
  eq q elemOf literals = false [owise] .

  eq q notElemOf literals = not (q elemOf literals) .

endfm

fmod RULE is
  pr BOOL .
  pr LITERALS .
  --- pr SET{Qid} .
  --- protecting PREF-REL .
  --- protecting META-LEVEL .

  sorts DefeasRule StrictRule DefeatRule .
  sorts UnnamedRule NamedRule NamedRules .
  sorts Arrow StrictArrow DefeasArrow DefeatArrow .
  sorts DefeasDefeatArrow StrictDefeasArrow .

  subsorts StrictArrow DefeasArrow < StrictDefeasArrow .
  subsorts DefeasArrow DefeatArrow < DefeasDefeatArrow .
  subsorts DefeasDefeatArrow StrictDefeasArrow < Arrow .
  subsorts DefeasRule StrictRule DefeatRule < UnnamedRule .

  ops ==> : -> DefeasArrow [ctor] .
  ops -> : -> StrictArrow [ctor] . 
  ops ~> : -> DefeatArrow [ctor] .

  ops ___ : Literal DefeasArrow Literal -> DefeasRule .
  ops ___ : Literal StrictArrow Literal -> StrictRule .
  ops ___ : Literal DefeatArrow Literal -> DefeatRule .

  --- ops _==>_ _~>_ _->_ : Literals Literal -> UnnamedRule [ctor] .

  ops _<_ : Literal Literal -> Bool .

  ops _:_ : Qid UnnamedRule -> NamedRule [ctor] .

  subsorts NamedRule < NamedRules .

  ops emptyRules : -> NamedRules [ctor] .
  ops _#_ : NamedRules NamedRules -> NamedRules
    [ctor assoc comm id: emptyRules] .

  vars namedRules : NamedRules .
  eq namedRules # namedRules = namedRules .

endfm

--- red 'r : ('q | 'p) ==> 'p .

--- view NamedRule from TRIV to RULE is
---   sort Elt to NamedRule .
--- endv

--- view Set`{NamedRule`} from TRIV to SET{NamedRule} is
---   sort Elt to Set`{NamedRule`} .
--- endv

mod DEFEAS-STATICS is
  pr RULE .
  pr META-LEVEL .

  sorts DefeasTheory .

  ops Atoms_Facts_Rules_PrefRel_ :
    Literals Literals NamedRules Module -> DefeasTheory .

endm

mod DEFEAS-DYNAMICS is
  pr DEFEAS-STATICS .

  vars p q q' : Literal .
  vars atom ruleName ruleName' : Qid .
  vars +∆ -∆ +∂ -∂ atoms facts literals literals' : Literals .
  vars rule : NamedRule .
  vars rules : NamedRules .
  vars prefRel : Module .
  vars arrow : Arrow .
  vars -=> : StrictDefeasArrow .
  vars =~> : DefeasDefeatArrow .
  vars -=~> : Arrow .
  vars defeasTheory : DefeasTheory .

---(
  Transition system for transfinite iteration to compute the colimit of the
  endofunctor F in page 10 of Guido's paper. 

  For details on fixpoint iteration, see:
  https://core.ac.uk/download/pdf/82239173.pdf

  Can we bound the ordinal height by omega for computability purposes?
  According to Guido, we can for propositional logic.
  How much higher do we need to go for first-oder?
)
  sorts FixptIterState .
  subsorts DefeasTheory < FixptIterState .

  --- theory | +∆ | -∆ | +∂ | -∂
  ops _|_|_|_|_ :
    DefeasTheory Literals Literals Literals Literals -> FixptIterState .

  --- Fixpoint iteration begins at ⊥ = ({}, {}, {}, {})
  ops initialize_ : DefeasTheory -> FixptIterState .
  eq initialize defeasTheory
  = defeasTheory
    | emptyLiterals | emptyLiterals | emptyLiterals | emptyLiterals .

---(
  Notes on metaSearch:
  https://www.uio.no/studier/emner/matnat/ifi/INF5130/h15/lectures/lecture4.pdf
)
  ops _<`[_`]_ : Qid Module Qid -> Bool .
  eq ruleName < [prefRel] ruleName'
  = metaSearch(
      prefRel, upTerm(ruleName), upTerm(ruleName'), nil, '+, unbounded, 0
  ) =/= failure .

  crl [+∆-fact] :
    Atoms (atom # atoms)
    Facts (q # facts)
    Rules rules
    PrefRel prefRel
    | +∆ | -∆ | +∂ | -∂
  =>
    Atoms (atom # atoms)
    Facts (q # facts)
    Rules rules
    PrefRel prefRel
    | (q # +∆) | -∆ | +∂ | -∂
  if q isLiteralOfAtom atom
  /\ q notElemOf +∆ .

  crl [+∆-strict-rule] :
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -> q) # rules)
    PrefRel prefRel
    | (literals # +∆) | -∆ | +∂ | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -> q) # rules)
    PrefRel prefRel
    | (q # literals # +∆) | -∆ | +∂ | -∂
  if q isLiteralOfAtom atom
  /\ q notElemOf +∆ .

 crl [-∆-positive-literal] :
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | -∆ | +∂ | -∂ 
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | (atom # -∆) | +∂ | -∂
  if atom notElemOf -∆
  /\ atom notElemOf facts
  /\ atom notProvableFrom rules -∆ .

 crl [-∆-negative-literal] :
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | -∆ | +∂ | -∂ 
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | (not atom # -∆) | +∂ | -∂
  if (not atom)  notElemOf -∆
  /\ (not atom) notElemOf facts
  /\ (not atom) notProvableFrom rules -∆ .

  ops _notProvableFrom__ : Literal NamedRules Literals -> Bool .

  eq q notProvableFrom emptyRules -∆ = true .
  
  eq q notProvableFrom ((ruleName : (p # literals) -> q) # rules) (p # -∆)
  = q notProvableFrom rules (p # -∆) .

  ceq q notProvableFrom ((ruleName : literals -=~> p) # rules) -∆
  = q notProvableFrom rules -∆
  if -=~> =/= -> or p =/= q .

  --- eq q notProvableFrom ((rulename : literals -~> p) # rules) -∆
  --- = q notProvableFrom rules -∆ .

  crl [+∂-definitely] :
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | (q # +∆) | -∆ | +∂ | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | (q # +∆) | -∆ | (q # +∂) | -∂
  if q isLiteralOfAtom atom
  /\ q notElemOf +∂ .

  crl [+∂-defeasibly] :
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -=> q) # rules)
    PrefRel prefRel
    | +∆ | (q' # -∆) | (literals # +∂) | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -=> q) # rules)
    PrefRel prefRel
    | +∆ | (q' # -∆) | (q # literals # +∂) | -∂
  if q isLiteralOfAtom atom
  /\ q' == ~ q
  /\ q notElemOf +∂
  /\ f q prefRel (literals # +∂) -∂ ((ruleName : literals -=> q) # rules) .

---(
  This function handles 2.3 in the definition of +∂
  We perform recursion on the set of input rules to handle the universal quantifier.
)
  ops f_____ : Literal Module Literals Literals NamedRules -> Bool .

  eq f q prefRel +∂ -∂ emptyRules = true .

  --- Case 2.3.1
  ceq f q prefRel +∂ (p # -∂) ((ruleName : (p # literals) -=~> q') # rules)
  = f q prefRel +∂ -∂ rules
  if q' == ~ q .

  --- Case 2.3.2
  ceq f q prefRel (literals' # +∂) -∂
    (
      (ruleName : (p # literals) -=~> q') #
      (ruleName' : literals' -=> q) #
      rules
    )
  = ruleName <[prefRel] ruleName'
  and f q prefRel (literals' # +∂) -∂ ((ruleName' : literals' -=> q) # rules)
  if q' == ~ q .

  ceq f q prefRel +∂ -∂ ((ruleName : literals -=~> p) # rules)
  = f q prefRel +∂ -∂ rules
  if p =/= ~ q .

  --- eq f q prefRel +∂ -∂ rules
  --- = false [owise] .

  crl [-∂-not-defeasibly-provable-2.1] :
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | (q # -∆) | +∂ | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | +∆ | (q # -∆) | +∂ | (q # -∂)
  if q isLiteralOfAtom atom
  /\ q notElemOf -∂
  /\ g q -∂ rules .

  ops g___ : Literal Literals NamedRules -> Bool .

  eq g q -∂ emptyRules = true .

  eq g q (p # -∂) ((ruleName : (p # literals) -=> q) # rules)
  = g q -∂ rules .

  ceq g q -∂ ((ruleName : literals -=~> p) # rules)
  = g q -∂ rules
  if -=~> == ~> or p =/= q .

  crl [-∂-not-defeasibly-provable-2.2] :
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | (q' # +∆) | (q # -∆) | +∂ | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    | (q' # +∆) | (q # -∆) | +∂ | (q # -∂)
  if q isLiteralOfAtom atom
  /\ q' == ~ q
  /\ q notElemOf -∂ .

  crl [-∂-not-defeasibly-provable-2.3] :
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -=~> q') # rules)
    PrefRel prefRel
    | +∆ | (q # -∆) | (literals # +∂) | -∂
  =>
    Atoms (atom # atoms)
    Facts facts
    Rules ((ruleName : literals -=~> q') # rules)
    PrefRel prefRel
    | +∆ | (q # -∆) | (literals # +∂) | (q # -∂)
  if q isLiteralOfAtom atom
  /\ q' == ~ q
  /\ q notElemOf -∂
  /\ h prefRel ruleName q -∂ rules .

  --- Case 2.3.2 of not defeasibly provable.
  ops h_____ : Module Qid Literal Literals NamedRules -> Bool .

---(
  h
    upModule('PREF-REL, false)
    'r2
    (not 'r)
    ('q # 'r # not 'p # not 'q)
    (('r1 : 'p -> 'r) # ('r2 : 'p -> not 'r))

    'r1 < 'r2
)
  eq h prefRel ruleName q -∂ emptyRules = true .

  eq h prefRel ruleName q (p # -∂) ((ruleName' : (p # literals) -=> q) # rules)
  = h prefRel ruleName q (p # -∂) rules .

  eq h prefRel ruleName q -∂ ((ruleName' : literals -=> q) # rules)
  = not (ruleName <[prefRel] ruleName')
  and h prefRel ruleName q -∂ rules .

  ceq h prefRel ruleName q -∂ ((ruleName' : literals -=~> p) # rules)
  = h prefRel ruleName q -∂ rules
  if -=~> == ~> or p =/= q .

endm

mod PROVER is
  pr DEFEAS-DYNAMICS .
  inc MODEL-CHECKER + SATISFACTION + LTL .

  subsorts FixptIterState < State .

  vars q : Literal .
  vars +∆ -∆ +∂ -∂ : Literals .
  vars defeasTheory : DefeasTheory .
  vars prop : Prop .

  ops _∈`+∆ _∈`-∆ _∈`+∂ _∈`-∂ : Literal -> Prop . 

  eq defeasTheory | (q # +∆) | -∆ | +∂ | -∂ |= q ∈ +∆ = true .
  eq defeasTheory | +∆ | (q # -∆) | +∂ | -∂ |= q ∈ -∆ = true .
  eq defeasTheory | +∆ | -∆ | (q # +∂) | -∂ |= q ∈ +∂ = true .
  eq defeasTheory | +∆ | -∆ | +∂ | (q # -∂) |= q ∈ -∂ = true .

  ops _⊢`+∆_ _⊢`-∆_ _⊢`+∂_ _⊢`-∂_ : DefeasTheory Literal -> Bool .

  op _ ⊨ ◊ □ _ : DefeasTheory Prop -> Bool .

  eq defeasTheory ⊨ ◊ □ prop
  = true == modelCheck(initialize defeasTheory, <> [] prop) .

  eq defeasTheory ⊢ +∆ q = defeasTheory ⊨ ◊ □ q ∈ +∆ .
  eq defeasTheory ⊢ -∆ q = defeasTheory ⊨ ◊ □ q ∈ -∆ .
  eq defeasTheory ⊢ +∂ q = defeasTheory ⊨ ◊ □ q ∈ +∂ .
  eq defeasTheory ⊢ -∂ q = defeasTheory ⊨ ◊ □ q ∈ -∂ .

endm

red
  Atoms ('p # 'q # 'r)
  Facts 'p
  Rules (('r1 : 'p ==> 'r) # ('r2 : 'p ==> not 'r))
---(
  A preference relation is the transitive closure of a one-step reduction
  relation given by a small-step operational semantics.
  In other words, we view the state space of the defined transition system as
  a thin category representing a poset.

  In simpler terms, this means we define a transition system with rules
  of the form 'r1 => 'r2, and we then take 'r3 < 'r4 to mean 'r4 is reachable
  from 'r3 in one or more steps.
)
  PrefRel (
    mod 'PREF-REL is
      protecting 'META-LEVEL .
      protecting 'QID .
      sorts none .
      none none none none
      --- 'r1 < 'r2
      rl ''r1.Sort => ''r2.Sort [none] . 
    endm
  )
  ⊢ +∂ not 'r .

--- rew in DEFEAS-DYNAMICS :
---   initialize (
---     Atoms ('p # 'q # 'r)
---     Facts 'p
---     Rules (('r1 : 'p -> 'r) # ('r2 : 'p -> not 'r))
---     PrefRel testPrefRel
---   ) .

--- set print attribute on .
--- set trace on .
--- continue 1 .

quit