---(
  Notes:
  https://ssa2020.dmi.unipg.it/res/DefeasibleLogic.pdf
)

fmod LITERALS is
  pr QID .
  pr BOOL .

  sorts Literal Literals .
  subsorts Qid < Literal < Literals .

  ops not_ : Qid -> Literal [ctor] .
  ops ~_ : Literal -> Literal .

  --- ops Literal < Bool .

  ops emptyLiterals : -> Literals [ctor] .
  ops _#_ : Literals Literals -> Literals
    [ctor assoc comm id: emptyLiterals] .
 
  vars q : Literal .
  vars literals : Literals .

  eq ~ q = not q .
  eq ~ (not q) = q .

  eq literals # literals = literals .

  ops _notIn_ : Literal Literals -> Bool .
  eq q notIn (q # literals) = false .
  eq q notIn literals = true [owise] .

endfm

fmod RULE is
  pr BOOL .
  pr LITERALS .
  --- pr SET{Qid} .
  --- protecting PREF-REL .
  --- protecting META-LEVEL .

  sorts UnnamedRule NamedRule NamedRules .

  ops _==>_ _~>_ _->_ : Literals Literal -> UnnamedRule [ctor] .

  ops _<_ : Literal Literal -> Bool .

  ops _:_ : Qid UnnamedRule -> NamedRule [ctor] .

  subsorts NamedRule < NamedRules .

  ops emptyRules : -> NamedRules [ctor] .
  ops _#_ : NamedRules NamedRules -> NamedRules
    [ctor assoc comm id: emptyRules] .

  vars namedRules : NamedRules .
  eq namedRules # namedRules = namedRules .

endfm

--- red 'r : ('q | 'p) ==> 'p .

--- view NamedRule from TRIV to RULE is
---   sort Elt to NamedRule .
--- endv

--- view Set`{NamedRule`} from TRIV to SET{NamedRule} is
---   sort Elt to Set`{NamedRule`} .
--- endv

mod DEFEAS-STATICS is
  pr RULE .
  pr META-LEVEL .

  sorts DefeasTheory .

  ops Atoms_Facts_Rules_PrefRel_ :
    Literals Literals NamedRules Module -> DefeasTheory .

endm

---(
  A preference relation is the transitive closure of the one step evaluation
  relation defined by a small-step operational semantics.

  In other words, a rewriting rule aka transition of the form
  rl 'rl => 'r2
  is interpreted as 'r1 < 'r2
)
mod PREF-REL is
  pr LITERALS .

  --- rl [r1_r2] : 'r1 => 'r2 .

endm

mod DEFEAS-DYNAMICS is
  pr DEFEAS-STATICS .

  vars p q : Literal .
  vars ruleName : Qid .
  vars +∆ -∆ +∂ -∂ atoms facts literals : Literals .
  vars rules : NamedRules .
  vars prefRel : Module .

  sorts State .
  ops _____ : DefeasTheory Literals Literals Literals Literals -> State .

---(
  These rewriting rules define a transition system which implements transfinite
  fixpoint iteration.
  For details, see page 10 of: https://arxiv.org/pdf/cs/0511055.pdf

  Can we bound the ordinal height by omega for computability purposes?
  According to Guido, we can for propositional logic.
  How much higher do we need to go for first-oder?
)
  crl [+∆-fact] :
    Atoms (q # atoms)
    Facts (q # facts)
    Rules rules
    PrefRel prefRel
    +∆ -∆ +∂ -∂
  =>
    Atoms (q # atoms)
    Facts (q # facts)
    Rules rules
    PrefRel prefRel
    (q # +∆) -∆ +∂ -∂
  if q notIn +∆ .

  crl [+∆-strict-rule] :
    Atoms (q # atoms)
    Facts facts
    Rules ((ruleName : literals ==> q) # rules)
    PrefRel prefRel
    (literals # +∆) -∆ +∂ -∂
  =>
    Atoms (q # atoms)
    Facts facts
    Rules ((ruleName : literals ==> q) # rules)
    PrefRel prefRel
    (q # literals # +∆) -∆ +∂ -∂
  if q notIn +∆ .

 crl [-∆] :
    Atoms (q # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    +∆ -∆ +∂ -∂ 
  =>
    Atoms (q # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    +∆ (q # -∆) +∂ -∂
  if q notIn -∆
  /\ q notIn facts
  /\ q notProvableFrom rules -∆ .

  ops _notProvableFrom__ : Qid NamedRules Literals -> Bool .

  eq q notProvableFrom emptyRules -∆ = true .

  eq q notProvableFrom ((ruleName : (p # literals) ==> q) # rules) (p # -∆)
  = q notProvableFrom rules (p # -∆) .

  eq q notProvableFrom rules -∆ = false [owise] .

  crl [+∂-definitely-provable] :
    Atoms (q # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    (q # +∆) -∆ +∂ -∂
  =>
    Atoms (q # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    (q # +∆) -∆ (q # +∂) -∂
  if q notIn +∂ .

  crl [+∂-defeasibly-provable-1] :
    Atoms (q # atoms)
    Facts facts
    Rules ((ruleName : literals ==> q) # rules)
    PrefRel prefRel
    +∆ (~ q # -∆) (literals # +∂) -∂
  =>
    Atoms (q # atoms)
    Facts facts
    Rules rules
    PrefRel prefRel
    +∆ -∆ (q # literals # +∂) -∂
  if q notIn +∂ 
  /\ f rules q +∂ -∂ .

  ops f____ : Literal Literals Literals NamedRules -> Bool .

  eq f q +∂ -∂ emptyRules = true .

  eq f q +∂ (p # -∂) ((ruleName : (p # literals) ==> ~ q) # rules)
  = f q +∂ (p # -∂) rules .

  --- eq f q +∂ (p # -∂) ((ruleName : (p # literals) ==> ~ q) # rules)

---(
  Notes on metaSearch:
  https://www.uio.no/studier/emner/matnat/ifi/INF5130/h15/lectures/lecture4.pdf
)
  --- ceq r1 < r2 = true
  --- if metaSearchPath(upModule('PREF-REL, false), r1, r2, nil, '+, unbounded, 0) =/= failure .

  --- crl [t] :
  ---   true => false
  --- if 'r1 < 'r2 .

  --- ops _<_ : Qid Qid -> PrefRel .

  --- ops _<[_]_ : Qid Set{Qid} Qid -> Bool .
endm

rew
  Atoms ('p # 'q # 'r)
  Facts ('p # 'q)
  Rules ('r1 : 'p ==> 'r)
  PrefRel upModule('PREF-REL, false)
  emptyLiterals emptyLiterals emptyLiterals emptyLiterals .

--- quit