load model-checker
load full-maude

(omod JUGS is
  protecting NAT .
  protecting LIST{Nat} .
  protecting INT .
  protecting QID .

  subsorts Qid < Oid .

  class Jug |
    maxCap : Nat,
    currCap : Int .

  vars J J' : Oid .
  vars maxCap maxCap' n n' : Nat .
  vars currCap currCap' : Int .
  vars ns : List{Nat} .

  ops mkJugs_ : List{Nat} -> Configuration .
  eq mkJugs nil = none .
  eq mkJugs (n ns) =
    < 'J : Jug | maxCap : n, currCap : 0 >
    mkJugs ns .

  --- ops initial : -> Configuration .
  --- eq initial = mkJugs 4 . 

  rl [fill-jug] :
    < J : Jug |
      maxCap : maxCap,
      currCap : currCap >
  =>
    < J : Jug |
      maxCap : maxCap,
      currCap : maxCap > .
  
  rl [empty-jug] :
    < J : Jug |
      currCap : currCap >
  =>
    < J : Jug |
      currCap : 0 > .

  crl [transfer-full] :
    < J : Jug |
      maxCap : maxCap,
      currCap : currCap >
    < J' : Jug |
      maxCap : maxCap',
      currCap : currCap' >
  =>
    < J : Jug |
      maxCap : maxCap,
      currCap : 0 >
    < J' : Jug |
      maxCap : maxCap',
      currCap : currCap + currCap' >
  if currCap + currCap' <= maxCap' .

  crl [transfer-partial] :
    < J : Jug |
      maxCap : maxCap,
      currCap : currCap >
    < J' : Jug |
      maxCap : maxCap',
      currCap : currCap' >
  =>
    < J : Jug |
      maxCap : maxCap,
      currCap : currCap + - (maxCap' + - currCap') >
    < J' : Jug |
      maxCap : maxCap',
      currCap : maxCap' >
  if currCap + currCap' > maxCap' .

endom)

(omod ATOMIC-PROPS is
  protecting JUGS .
  including MODEL-CHECKER + SATISFACTION . 

  subsorts Configuration < State .

  vars config : Configuration .
  vars J : Oid .
  vars cap : Nat .

  ops someJugHasCap_ : Nat -> Prop .
  eq < J : Jug | currCap : cap > config |= someJugHasCap cap
  = true .

endom)

(smod JUGS-STRAT is
  protecting JUGS .
  protecting ATOMIC-PROPS .

  vars config : Configuration .
  vars cap : Nat .

---(
  Simple goal directed execution strategy, in which we try to find a
  configuration where some jug contains cap amount of water.

  Note that as per the semantics of the strategy language (see Propositions
  5 and 6 of https://eprints.ucm.es/id/eprint/67449/1/slang.pdf), in the presence
  of a finite state space, the strategy language covers the whole space of
  omega-regular expressions.
  By the papers cited in  
  https://cs.stackexchange.com/questions/108/equivalence-of-b%C3%BCchi-automata-and-linear-mu-calculus
  omega-regexs have the same expressive power as Buchi automata and the _linear_
  mu calculus.
  Moreover, these are strictly more expressive than LTL.

  In particular, this strategy is equivalent to the linear mu calculus formula
  mu X. someJugHasCap cap \/ (not someJugHasCap cap /\ O X)
  Note that this is NOT the same as the LTL formula <> someJugHasCap cap
  because the former says that we begin searching from the initial state of the
  transition system (viewed as a Kripke structure) and then stop the instant
  we reach a state in which the state formula (someJugHasCap cap) holds.
  In other words, every model of this formula cannot have any outgoing transitions
  from goal states.

  The umaudemc tool allows us to compute the intersection of the Kripke structures
  corresponding to:
  - the buchi automata corresponding to strategy
  - the transition system defined by the above rewriting rules
  This lets us generate a DFA showing all possible ways of reaching goal states.
)
  strat simple : Nat @ Configuration .

  --- mu X.
  sd simple(cap) :=
    --- someJugHasCap cap
    match config s.t.
      config |= someJugHasCap cap
    --- \/ (not someJugHasCap cap /\
    or-else
      --- O
      all ;
      --- X
      simple(cap) .
    --- )

endsm)

(show all .)
q

eof

set trace on .
trace exclude FULL-MAUDE .

(srewrite
  mkJugs (1 4) using simple(3)
.)