% Contract parameters
% These can be redefined as appropriate.
map
	% This indicates how many payments there are in total.
	total_num_payments : Pos;

	% This tells us how much the borrower has to pay in each payment.
	payment_amt : Pos -> Pos;

	% The principal amount the lender sends the borrower.
	principal_amt : Pos;

	% This is the initial amount that the borrower owes the lender.
	initial_outstanding_amt : Pos;

var n : Pos;

eqn
	total_num_payments = 2;

	principal_amt = 1000;

	initial_outstanding_amt = 1075;

  (n == 1) -> payment_amt(n) = 550;
  (n == 2) -> payment_amt(n) = 525;

sort
  % Union type indicating the 3 types of payments involved in the loan agreement.
  % This is used to parameterize the pay* actions.
	PaymentType = struct normal | accelerated | principal;
	Party = struct borrower | lender;

act
	pay_s, pay_r, pay, payment_default : PaymentType # Party # Party # Nat;
  borrower_default,

	request_principal, cure_default,
	breach_s, breach_r, breach, breached,
  fulfill_s, fulfill_r, fulfill, fulfilled,
	notify_borrower_of_default,

  dont_notify_borrower, dont_cure_default, dont_request_principal,

  start_init_s, start_init_r, start_init,
  stop_init_s, stop_init_r, stop_init,
  start_main_s, start_main_r, start_main,
  stop_main_s, stop_main_r, stop_main,
  start_side_s, start_side_r, start_side,
  stop_side_s, stop_side_r, stop_side,
  start_accel_s, start_accel_r, start_accel,
  stop_accel_s, stop_accel_r, stop_accel;

  remaining_payments_s, remaining_payments_r, remaining_payments,
  outstanding_s, outstanding_r, outstanding : Nat;

  next_payment_number_s, next_payment_number_r, next_payment_number : Pos;

proc
	Breached = breached . Breached;
	Fulfilled = fulfilled . Fulfilled;

  % Main_idling is a process representing the process Main_track in an idl
  % state.
  % In such a idle state, we can:
  % - Receive a stop signal, ie stop_main_r, in which case we transition back
  %   to this idle state.
  % - Receive a start signal, ie start_main_r, in which case we transition to
  %   Main_track and begin executing there.
  %
  % Note here that we allow Main_track to be interrupted by decorating each
  % atomic, non-internal, action in Main_track with the process Stop_main_r, so
  % that an action a becomes (a + Stop_main_r).
  % This means that whenever Main_track is executing, it listens out for
  % the stop signal and when it receives such a signal, it transitions back to
  % this idle state.
  Main_idling =
    stop_main_r . Main_idling + start_main_r . Main_track . Main_idling;
  Stop_main_r = stop_main_r . Main_idling;

  Side_idling =
    stop_side_r . Side_idling + start_side_r . Side_track . Side_idling;
  Stop_side_r = stop_side_r . Side_idling;

  Init_idling =
    stop_init_r . Init_idling + start_init_r . Init . Init_idling;
  Stop_init_r = stop_init_r . Init_idling;

  Accel_idling =
    stop_accel_r . Accel_idling + start_accel_r . Accel . Accel_idling;
  Stop_accel_r = stop_accel_r . Accel_idling;

  % Start of the loan agreement.
	Init =
    % First the borrower may or may not request for the principal amount.
    % If he doesn't then the contract is immediately fulfilled.
		(dont_request_principal + Stop_init_r) . fulfill_s

    % Otherwise, the lender is now obliged to send the principal.
		+ (request_principal + Stop_init_r). (

        % If the Lender defaults on the payment of the principal, the
        % contract is deemed to be breached.
			  (payment_default(principal, lender, borrower, principal_amt) + Stop_init_r) .
        breach_s

        % Otherwise, if he does send the principal, then we start the main and
        % side tracks.
			  + (pay(principal, lender, borrower, principal_amt) + Stop_init_r) .
          start_main_s . start_side_s
		  );

  % Main repayment track of the loan agreement.
	Main_track = sum n : Pos.
    % First we determine the next payment number, ie is it payment 1, payment 2,
    % etc.
    % This is done via the next_payment_number_s action, which is
    % synchronized with the corresponding next_payment_number_r action of
    % the Outstanding process.
    %
    % Note that this Outstanding process helps us keep track of the number of
    % remaining payments, as well as the outstanding amount that the borrower
    % has yet to repay.
    %
    % Note also that since the Main_track process is "parameterized" over this
    % global state, starting up the Main_track process again after stopping it
    % actually has the effect of resuming where it left off, rather than
    % starting all the payment stages from scratch.
    next_payment_number_s(n) .

    % If all payments have been made, we perform fulfill_s, which signals that
    % the contract has been fulfilled.
    (n > total_num_payments) -> 
      fulfill_s
    <> (
      % Otherwise, if there are outstanding payments, the borrower is obliged
      % to pay the current payment.
      % If such a payment is made, we continue down the main repayment track.
      (pay_s(normal, borrower, lender, payment_amt(n)) + Stop_main_r) .
      Main_track

      % If the borrower defaults on the payment, we continue here instead.
      % At this point, the lender has the option to notify the borrower.
      + (payment_default(normal, borrower, lender, payment_amt(n)) + Stop_main_r) . (

        % If the lender doesn't notify the borrower upon payment default,
        % nothing goes wrong and so we simply continue with repayments.
        (dont_notify_borrower + Stop_main_r) . Main_track

        % If the lender does notify the borrower, then the borrower is obliged
        % to cure his default.
        + (notify_borrower_of_default + Stop_main_r) . (

          % If the borrower cures his default, then we contiunue down the
          % repayment track, giving him another chance to pay off the current
          % payment.
          (cure_default + Stop_main_r) . Main_track

          % If the default is not cured, the borrower is then obliged to make
          % an accelerated payment of the remaining amount to the lender.
          % The start_accel_s action is used to kick off the
          % Accel process, which handles this accelerated repayment stage.
          + (dont_cure_default + Stop_main_r) .
            start_accel_s
          )
        )
      );

  % Side track that waits for a borrower default event to occur, and then
  % executes accordingly.
	Side_track =
    % When a borrower default event occurs, the lender has the option of
    % notifying the borrower.
		(borrower_default + Stop_side_r) . (

      % If no such notification occurs, nothing happens and so we loop back to
      % the top of the side track and wait for another default event to occur.
			(dont_notify_borrower + Stop_side_r) . Side_track

      % If the lender does notify the borrower, then we proceed as we did in the
      % main track above, ie the borrower is then obliged to cure his default,
      % and failing which, he is then obliged to make an accelerated payment
      % of the remaining amount.
			+ (notify_borrower_of_default + Stop_side_r) . (
				(cure_default + Stop_side_r) . Side_track
        + (dont_cure_default + Stop_side_r) .
          start_accel_s
	    )
    );

  % Process that handles the accelerated repayments stage of the loan agreement.
  % This situation occurs when the borrower fails to cure his default after
  % being notified by the lender about it.
  Accel =
    % The first thing we do here is we stop the main and side tracks.
    stop_main_s . stop_side_s . (
      sum outstanding : Pos.
        % Next we grab the outstanding amount from the Outstanding process.
        % Then, the borrower has an obligation to pay off this outstanding
        % amount.
        % If he does, we signal that the contract is fulfilled.
        % Otherwise, we signal that the contract has been breached.
        outstanding_s(outstanding) . (
          (pay_s(accelerated, borrower, lender, outstanding)
            + pay_s(accelerated, borrower, lender, outstanding)
            + Stop_accel_r) .
          fulfill_s
          + (payment_default(accelerated, borrower, lender, outstanding)
              + payment_default(accelerated, borrower, lender, outstanding)
              + Stop_accel_r) .
            breach_s
        )
    );

  % This Outstanding process functions like a mutable object that keeps track of
  % the global state of the loan agreement, ie it tracks the number of payments
  % remaining and the outstanding amount.
  % There are 2 getters for these 2 parameters, which we can view as "fields"
  % of the "object" and a synchronized pay_r action which "mutates" these 2
  % "fields".
  %
  % next_payment_number_r computes the next payment number as a function
  % of the number of remaining payments.
  %
  % pay_r(accelerated, borrower, lender, outstanding) indicates that the
  % borrower pays the lender an accelerated payment of the outstanding amount.
  % Notice how we recurse with the remaining number of payments and outstanding
  % amount set to 0 since no payments remain thereafter.
  %
  % pay_r(normal, borrower, lender, amt_paid) indicates that the borrower pays
  % a normal repayment of amt_paid to the lender.
  Outstanding(remaining_payments : Nat, outstanding : Nat) =
    remaining_payments_r(remaining_payments) .
    Outstanding(remaining_payments, outstanding)

    + next_payment_number_r(Int2Pos(max(1, total_num_payments - remaining_payments + 1))) .
      Outstanding(remaining_payments, outstanding)

    + outstanding_r(outstanding) .
      Outstanding(remaining_payments, outstanding)

    + pay_r(accelerated, borrower, lender, outstanding) .
      Outstanding(0, 0)

    + sum amt_paid : Pos. (
        pay_r(normal, borrower, lender, amt_paid) .
        Outstanding(
          remaining_payments = Int2Nat(max(0, remaining_payments - 1)),
          outstanding = Int2Nat(max(0, outstanding - amt_paid))
        )
      );

  % Helper process that stops all processes in the contract.
  Stop_all = stop_init_s . stop_main_s . stop_side_s . stop_accel_s;

init
  % Here we synchronize a lot of the *_r and *_s actions and block them from
  % occuring individually.
  % This forces a pair of a_r and a_s actions to behave like pairs of broadcasts
  % a? and a! as in UPPAAL.
  % Since we want to treat these transitions as internal, ie users don't need
  % to see or care about them, we hide them so they become tau transitions.
  % Moreover, when converting this to an LTS, we instruct the mcrl2 tools to
  % prioritize these tau transitions, so that they are automatically taken and
  % eliminated from the resulting LTS.
  % This is the same idea behind eliding internal nodes when constructing
  % and stitching together petri nets.
  hide({
    remaining_payments, next_payment_number, outstanding,
    start_init, stop_init,
    start_main, stop_main,
    start_side, stop_side,
    start_accel, stop_accel,
    fulfill, breach
  },
  allow({
    fulfill, fulfilled, breach, breached,
    start_init, stop_init, start_main, stop_main,
    start_side, stop_side, start_accel, stop_accel,
    remaining_payments, next_payment_number, outstanding, pay,
    request_principal, dont_request_principal,
    borrower_default, payment_default,
    notify_borrower_of_default, dont_notify_borrower,
    cure_default, dont_cure_default
  },
	comm({
    fulfill_s|fulfill_r -> fulfill,
    breach_s|breach_r -> breach,
    start_init_s|start_init_r -> start_init,
    stop_init_s|stop_init_r -> stop_init,
    start_main_s|start_main_r -> start_main,
    stop_main_s|stop_main_r -> stop_main,
    start_side_s|start_side_r -> start_side,
    stop_side_s|stop_side_r -> stop_side,
    start_accel_s|start_accel_r -> start_accel,
    stop_accel_s|stop_accel_r -> stop_accel,
    pay_s|pay_r -> pay,
    remaining_payments_s|remaining_payments_r -> remaining_payments,
    next_payment_number_s|next_payment_number_r -> next_payment_number,
    outstanding_s|outstanding_r -> outstanding
	},
  % The 4 main phases of the contract:
  % - The initialization phase, where the principal is requested and so on.
  % - The main repayment track.
  % - The side borrower default on representations, warranties etc track.
  % - The accelerated repayment track, which kicks in when the borrower
  %   defaults, either on payments in the main track or representations, warranties
  %   etc in the side track.
  Init_idling
  || Main_idling
  || Side_idling
  || Accel_idling

  % Initialize the contract by signalling the Init process to start.
  || start_init_s

  % Wait for a fulfill/breach signal to transition to the Fulfilled/Breached
  % state.
  % For safety, we stop all processes in between these events.
  || (fulfill_r . Stop_all . Fulfilled
      + breach_r . Stop_all . Breached)

  % Process which functions like a "mutable object" carrying the global state,
  % ie the remaining number of payments and outstanding amount.
  || Outstanding(total_num_payments, initial_outstanding_amt)
  )));