% Contract parameters
map
	% This indicates how many payments there are in total.
	num_payments : Pos;

	% This tells us how much the borrower has to pay in each payment.
	payment_amt : Pos -> Pos;

	% The principal amount the lender sends the borrower.
	principal_amt : Pos;

	% This is the initial amount that the borrower owes the lender.
	initial_outstanding_amt : Pos;

	% remainder : Pos;

var n : Pos;

eqn
	num_payments = 2;

	principal_amt = 1000;

	initial_outstanding_amt = 1075;

	(n == 1) -> payment_amt(n) = 550;
	(n == 2) -> payment_amt(n) = 525;

  % The following clause is included for completeness so that payment_amt is a
  % total function on Pos.
  % Sigma types would be nice here :^)
	(n >= 3) -> payment_amt(n) = 1;

sort
	PaymentType = struct normal | accelerated | principal;
	Party = struct borrower | lender;

act
	pay, payment_default : PaymentType # Party # Party # Nat;
  borrower_default,

	request_principal, cure_default,
	breached, fulfilled,
	notify_borrower_of_default,

  dont_pay, dont_notify_borrower, dont_cure_default, dont_request_principal,

  start_main, start_side, start_main_and_side,
  broadcast_terminate_main, receive_terminate_main,
  broadcast_terminate_side, receive_terminate_side,
  start_accelerated,
  sync, invalid;

  broadcast_update_remainder, receive_update_remainder, update_remainder,
  broadcast_get_remainder, receive_get_remainder, get_remainder : Nat;

proc
	Breached = breached . Breached;
	Fulfilled = fulfilled . Fulfilled;

  Receive_terminate_main = receive_terminate_main . delta;
  Terminate_side_r = receive_terminate_side . delta;

  % Start of the loan agreement.
	Start =
    % First the borrower may or may not request for the principal amount.
    % If he doesn't then the contract is immediately fulfilled.
		dont_request_principal . Fulfilled

    % Otherwise, the lender is now obliged to send the principal.
		+ request_principal . (

        % If the Lender defaults on the payment of the principal, the
        % contract is deemed to be breached.
			  payment_default(principal, lender, borrower, principal_amt) . Breached

        % Otherwise, if he does send the principal, then we start the main and
        % side tracks.
			  + pay(principal, lender, borrower, principal_amt) . start_main_and_side
		  );

  % PayPayments(n) is a helper process that handles all the payments from
  % payment n all the way up to num_payments.
  % MainTrack starts this off with n = 1.
	MainTrack = PayPayments(1);

	PayPayments(n : Pos) =
    % If all payments have been made, we terminate the side track and go to a
    % fulfilled state.
    (n > num_payments) ->
      broadcast_terminate_side . Fulfilled
    <>
      % Otherwise, if there are outstanding payments, the borrower is obliged
      % to pay the current payment.
      % When that is done, we trnsition to payment (n + 1).
      (pay(normal, borrower, lender, payment_amt(n))|broadcast_update_remainder(payment_amt(n)) + Receive_terminate_main) .
      PayPayments(n + 1)

      % We continue here if the borrower defaults on the payment.
      % At this point, the lender has the option to notify the borrower.
      + (payment_default(normal, borrower, lender, payment_amt(n)) + Receive_terminate_main) . (

        % If the lender doesn't notify the borrower upon payment default,
        % nothing goes wrong and so we simply move on to the next payment stage.
        (dont_notify_borrower + Receive_terminate_main) . PayPayments(n + 1)

        % If the lender does notify the borrower, then the borrower is obliged
        % to cure his default.
        + (notify_borrower_of_default + Receive_terminate_main) . (

          % If the borrower cure his default, then he gets another chance to
          % pay off the current payment.
          (cure_default + Receive_terminate_main) . PayPayments(n)

          % If the default is not cured, the borrower is then obliged to make
          % an accelerated payment of the remaining amount to the lender.
          + (dont_cure_default|start_accelerated + Receive_terminate_main)
        )
      );

  % Side track that waits for a borrower default event to occur, and then
  % executes accordingly.
	SideTrack =
    % When a borrower default event occurs, the lender has the option of
    % notifying the borrower.
		(borrower_default + Terminate_side_r) . (

      % If no such notification occurs, nothing happens and so we loop back to
      % the top of the side track and wait for another default event to occur.
			(dont_notify_borrower + Terminate_side_r) . SideTrack

      % If the lender does notify the borrower, then we proceed as we did in the
      % main track above, ie the borrower is then obliged to cure his default,
      % and failing which, he is then obliged to make an accelerated payment
      % of the remaining amount.
			+ (notify_borrower_of_default + Terminate_side_r) . (
				(cure_default + Terminate_side_r) . SideTrack
        + (dont_cure_default|start_accelerated + Terminate_side_r)
	    )
    );

  AcceleratedRepayment =
    broadcast_terminate_main . broadcast_terminate_side . (
      sum remainder : Pos.
        broadcast_get_remainder(remainder) . (
          pay(accelerated, borrower, lender, remainder) . Fulfilled
          + payment_default(accelerated, borrower, lender, remainder) . Breached
        )
    );

  Remainder(remainder : Nat) =
    receive_get_remainder(remainder) . Remainder(remainder)
    + sum paid : Pos.
        (remainder >= paid) ->
          receive_update_remainder(paid) .
          Remainder(Int2Nat(remainder - paid));

init
	block({
    start_main, start_side, start_main_and_side, start_accelerated,
    receive_terminate_main, receive_terminate_side,
    broadcast_get_remainder, receive_get_remainder,
    broadcast_update_remainder, receive_update_remainder
	},
  hide({
    broadcast_terminate_main, broadcast_terminate_side,
    update_remainder, get_remainder
  },
  % comm({
  %   broadcast_terminate_side|broadcast_terminate_main -> invalid
  %   % fulfilled|breached -> invalid
  % },
	comm({
		start_main_and_side|start_main|start_side -> sync,
    broadcast_terminate_main|receive_terminate_main -> sync,
    broadcast_terminate_side|receive_terminate_side -> sync,
    start_accelerated|start_accelerated -> sync,
    broadcast_update_remainder|receive_update_remainder -> update_remainder,
    broadcast_get_remainder|receive_get_remainder -> get_remainder
	},
  Start
	|| start_main . MainTrack
	|| start_side . SideTrack
  || start_accelerated . AcceleratedRepayment
  || Remainder(1075)
  )));