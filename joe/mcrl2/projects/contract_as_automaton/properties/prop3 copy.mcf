% Tip:
% Denotationally, mu X. phi (resp. nu X. phi) is interpreted as an initial F-algebra
% (resp. final coalgebra) where the functor F is given by the dentotation of phi.
% Syntactic restrictions ensure that F is semantically monotonic, so that
% we can understand this as bottom-up (resp. top-down) iteration.
%
% Note that our system being finitely branching ensures the Scott continuity
% of this operator so that we can cut off the transfinite iteration at omega.
% In short, the intuitive bottom-up reading of mu agrees with its semantics.
mu X(
  num_payments : Nat = 0,
  total_paid : Nat = 0,
  principal_received : Bool = false,
  fulfilled : Bool = false,
  breached : Bool = false
).
% Base case.
(
  ([true] false) => (
    val((fulfilled && !breached) || (!fulfilled && breached))
    % val(!fulfilled && !breached)
    && val(num_payments <= 2)
    && val(
        (principal_received && fulfilled) =>
          total_paid == initial_outstanding_amt
    )
    && val(breached => total_paid < initial_outstanding_amt)
  )
)
% Recursive cases.
&& (
  [fulfilled] X(num_payments, total_paid, principal_received, true, breached)
)
&& (
  [breached] X(num_payments, total_paid, principal_received, fulfilled, true)
)
&& (
  [exists amt : Pos. pay(Principal, Lender, Borrower, amt)]
    X(num_payments, total_paid, true, fulfilled, breached)
)
&& (
  exists amt : Pos. ( 
    [exists pt : Payment_type. pay(pt, Borrower, Lender, amt)]
    X(num_payments + 1, total_paid + amt, principal_received, fulfilled, breached)
  )
)
&& (
  [
    !fulfilled && !breached &&
    !(exists pt : Payment_type, p1, p2 : Party, amt : Pos. pay(pt, p1, p2, amt))
  ]
  X(num_payments, total_paid, principal_received, fulfilled, breached)
)
% && ([dont_request_principal] X(num_payments, total_paid, principal_received, fulfilled, breached))