sort Place = struct p0 | p1 | p2;
sort Trans = struct trans(
  trans_name : Trans_name,
  from : Set(PlaceTokens),
  to : Set(PlaceTokens)
);

sort PlaceTokens = struct place_tokens(place' : Place, tokens' : Bag(Token));

sort Trans_name = struct t0 | t1 | t2;

sort Token = Singleton;
sort Marking = Place -> Bag(Token);

sort Singleton = struct singleton;

map
  initial_marking : Marking;
  transitions : Set(Trans);

  is_enabled : Marking # Trans -> Bool;

var marking : Marking, t : Trans;

eqn
  initial_marking =
    (lambda place : Place. Set2Bag({}))[p0 -> {singleton: 1}];

  is_enabled(marking, t) =
    forall p : Place, b : Bag(Token).
      (place_tokens(p, b) in from(t)) => b <= marking(p);

act fire_trans : Trans_name;

proc
  P(marking : Marking) = sum t : Trans.
    (t in transitions) -> (
      fire_trans(trans_name(t)) .
      P(if(is_enabled(marking, t), marking, marking))
    );

  % T0(marking : Marking) =
  %   (count(singleton, marking(p0)) >= 1) ->
  %     t0 .
  %     P(
  %       marking[p0 -> marking(p0) - {singleton: 1}][p1 -> marking(p1) + {singleton: 1}][p2 -> marking(p2) + {singleton: 1}]
  %     );

init P(initial_marking);