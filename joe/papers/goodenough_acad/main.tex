\documentclass{article}
\usepackage[utf8]{inputenc}

\input{preamble}

% Title information
\title{Formalizing a simple loan agreement in mcrl2}
\author{Joe Watt}
% \date{June 2022}

\begin{document}

% Title and table of contents.
\maketitle

\info{
  This is a work in progress.
}

\tableofcontents

% Main body.
\section{Intro and shortcomings of DFA formalization}

\subsection{Intro}

\inlinetodo{
  Write a better intro and provide more background on
  \cite{contract_as_automaton}.
}

In \cite{contract_as_automaton}, the authors claim that many financial
contracts are inherently computational in nature.
They argue that the computational structure of many such contracts
can be formalized via deterministic finite automata (DFAs), with states
representing various situations.
% like ``borrower default'' and ``payment due''.
Transitions between these states then correspond to events triggering a change
in these situations.
This is demonstrated using a simple loan agreement
\cite[Table 1]{contract_as_automaton}, which they formalize
directly as a DFA.
% Finally, they claim that such a formalism opens up the possibility of performing
% automated analyses on contracts.

\subsection{Shortcomings}

While this approach is a nice proof of concept, there are various shortcomings
with such a formalism, perhaps the most apparent being that the manual encoding
of a contract as a DFA is a laborious process.
A simplified, arguably inaccurate, visual representation of the automaton
\cite[Fig. 1]{contract_as_automaton}
corresponding to this simple contract already contains more than 20 states and
40 transitions.
Here, we discuss 2 reasons contributing to the complexity involved with a more
accurate formalization of the contract as a DFA.
We claim that even for such a simple contract, a more accurate formalization
as a DFA is too impractical to be carried out by hand.

The first source of complexity is a consequence of DFAs not having an explicit
notion of global variables, as well as their inability to
perform arithmetic computations.
To see this, observe how there are verbose duplication of
``Payments \dots \, accelerating'' states.
Note here that when we say ``duplication'', we do not mean that there are states
which play exactly the same role from the point of view of bisimilarity or
language acceptance as in the sense of the Myhill-Nerode technique of DFA
minimization.
What we mean instead is that these states play similar roles, and viewing the
DFA as a graph, the subgraphs rooted at these states have similar structure.

Viewing these subgraphs as sub-automata, we see that they both accept
similar sequences of events from the point when the borrower defaults and is
obliged to make an accelerated repayment of the outstanding amount.
Notice that the key difference between them is the ``Payment made $\$n$''
transition, corresponding to the event that the borrower pays off the
outstanding amount of $\$n$.
While we would like to collapse both of these subgraphs into a single one,
this is not possible as the value of $n$ varies at runtime, with the current
state of the contract, ie with the number of payments the borrower has paid off
previously.
In other words, $n$ can be thought of as a global variable whose actual value
is updated at runtime, whenever payment events occur.
However, DFAs do not have a notion of global state, nor can they perform
sophisticated computations like arithmetic ones, so that these values must
be manually computed by hand and then encoded in the DFA.
The result of this manual encoding is the aforementioned duplication of states
and transitions.
Now, if the contract were to contain more than just 2 repayment stages, more
manual computations would be required, resulting in even more duplicated states
and transitions that would then need to be added to the DFA.

% Consequently, a more practical formalism should provide mechanisms like
% global variables and arithmetic operations.

% Such an issue could be addressed by a formalism that is more sophisticated than
% a DFA, something that allows for global variables, which can be updated at
% runtime.

% Ideally, we would like to be able to collapse these into a single subgraph
% corresponding to the``accelerated repayments'' phase of the contract.
% However, this is not possible here as both accelerated repayment stages as in
% the 

% Likewise, the transitions between them are similar as well, with the only
% difference being the 

% % verbose duplication of states along the main ``happy path''.

% What we mean instead is that there are similarly named states whose subgraphs
% have similar structure.
% These include the 2 main repayment stages along this path, given by the
% ``Payment\dots accruing'' states.
% Each of the subgraphs rooted at these nodes has a similar structure, with
% borrower default events giving rise to transitions to the unhappy paths.
% These in turn also have similar structure, with similar
% ``Payment\dots accelerating'' and ``Crisis\dots'' states.
% The only difference between the transitions between these states is

The second source of complexity arises from the concurrent interleaving
of real world events.
Perhaps for the sake of simplicity, this has not been accounted for in the DFA
formalization.
As an example of such a scenario that is not handled by the DFA, consider the
following.
On May 31, 2015, the day before payment 1 is due, the borrower defaults on his
representations and warranties.
On the next day, when payment 1 becomes due, the borrower diligently
repays that payment.
One day later, on June 2, 2015, the lender notifies the borrower of his
earlier default, which does not get cured after another 2 days.
Now all outstanding payments become accelerated, and the borrower pays off
the remaining amount of \$525 in time, causing the contract to terminate.
This sequence of events, when viewed as a word over the event alphabet, is
unfortunately not accepted by the automaton.

Closer inspection of the DFA suggests that there is an
implicit assumption being made that once an event of default occurs,
the borrower will be notified by the lender soon after, with no other events
like payments occurring in between.
More formally, it is assumed that the default and notification events occur
\textit{within the same atomic step}.
One could argue that the real world is inherently concurrent and asynchronous
in nature, so that a more realistic encoding of this contract would
account for such interleaving of events.
Of source, doing so would significantly increase the complexity of the DFA,
and consequently, the labor involved with its manual construction.

% It should be noted here that this only poses problems in the manual encoding
% of a contract, by hand, as a DFA.
% For the purposes of automated reasoning as in the field of 
% \textit{formal verification}, model checking tools like UPPAAL
% \todo{cite properly here}
% are able to automatically analyze automata comprising thousands of states.

Therefore, we argue that this evinces that accurately
encoding contracts as a DFA directly is too laborious and difficult,
even for a contract as simple as the one presented in
\cite[Fig 1.]{contract_as_automaton}.
In our view, a more practical formalism should sit at a higher-level than a DFA,
providing mechanisms for tackling these 2 issues.
Firstly, it should provide global variables, or at least, some way of encoding
global state.
There should also be operations that allow us to retrieve and update the global
state.
Secondly, it should be able to conveniently accommodate the concurrency
inherent in the real world.
% Consequently, we believe that a practical formalism for encoding contracts
% should be something higher-level than a DFA, one that can conveniently
% accommodate the concurrency inherent in the real world.
Better still if the formalism comes with tools that allow us to compile down
to something like automata for visualization and automated reasoning.

% However, it should be noted that for the purposes of visualization and
% automated reasoning in the sense of \textit{formal verification}, DFAs are a
% suitable choice of formalism.
% Indeed, tools such as UPPAAL \todo{list more tools and cite properly} are able to
% efficiently simulate and analyze automata with thousands of states.
% In fact, these tools rely on analyzing \textit{labelled transition systems},
% generalizations of nondeterministic finite automata (NFA) that allow for
% infinitely \footnote{Possibly uncountably} many states and transitions.

\section{Our approach}

In search for such a suitable formalism for encoding contracts,
we have surveyed various approaches, using the simplified contract in
\cite[Fig 1.]{contract_as_automaton} as an example.
One of these which we explored is the \mcrl \, toolset
\cite{mcrl_toolset}, which provides a high-level modeling language based on a
process algebra \cite{mcrl_book}.

In this section, we begin by providing some background on \mcrl before
we discuss our formalization of the simple loan agreement and along
the way, we explain how we addressed the aforementioned shortcomings.
In particular, we show how we can generate an arguably more accurate DFA that
accounts for the concurrent interleaving of real world events.
Thereafter, we demonstrate how we can use the \mcrl \, toolset to help us
visualize and reason about the contract.

\inlinetodo{
  May also want to cover other related approaches, like
  Symboleo and how they use
  nuxmv for verification.
  Need to investigate how they model that further first.

  Should mention limitations of our approach, the most obvious being that
  we don't handle real-time.
}

\subsection{Background on mcrl2}
Techniques originating from the field of formal methods have been devised to
automatically analyze the behavior of computer systems.
These often rely on first modelling these systems as
\textit{labelled transition systems} (LTS), which can be seen as
generalizations of nondeterministic finite automata (NFA).
As with finite automata, LTSes can be seen as directed graphs, with nodes
representing states that the system can be in, and labelled edges denoting
transitions that change the state of a system.
Where they differ from finite automata is that they are allowed to have an
infinite \footnote{Possibly uncountable} number of states and transitions
between them.
They are also not required to come with a notion of initial and final states.

While DFAs and LTSes in general are formalisms that are well suited for
computers to analyze and reason about, they are cumbersome for humans to use
to encode systems.
This is especially so for systems like the simple loan agreement of
\cite{contract_as_automaton} which involve concurrency, in that there are
many possible ways in which events can be interleaved.
\todo{
  May be good to explain what is ``concurrent interleaving'' a bit more.
}
Modelling concurrent systems like this directly as a transition system is
often impractical as the interleaving of events gives rise to numerous states
and transitions.

The toolset we use, \mcrl, allows us to model and analyze such concurrent systems.
As with others like it, it comes equipped with a more sophisticated formalism
that allow us to more conveniently specify these transition systems.
% Given a specification expressed in the provided formalism, these tools
% automatically generate the corresponding LTS, which they can then analyze.
In the case of \mcrl, the formalism it uses is a textual specification
language \cite{mcrl_book} based on a variant of the process algebra known
as the Algebra of Communicating Processes (ACP).
It also comes with a data language that allows for us to define abstract data
types built on top of primitive types like booleans and natural numbers.
A specification can then be simulated and visualized using the provided tools.
For automated reasoning, we can use the provided tools to verify properties
expressed in a first-order modal $\mu$-calculus.
Witnesses (resp. counter-examples) can then be provided for successful
(resp. failed) verifications.

As an example, one can define a binary search tree as such:
\begin{verbatim}
sort
  Tree = struct
    Empty
    | T(left : Tree, value : Nat, right : Tree);
\end{verbatim}
Here we define a \texttt{Tree} sort of natural numbers with 2 constructors,
namely \texttt{Empty} and \texttt{T}, the second of which has 3 parameters which
can be projected via functions \texttt{left}, \texttt{value} and \texttt{right}.
Readers familiar with functional programming will recognize that this is
reminiscent of algebraic data types.

With this, we can define an insert function with the following equations.

\begin{verbatim}
map insert : Nat # Tree -> Tree;

var t, t' : Tree; n, m : Nat;

eqn
  insert(n, Empty) = T(Empty, n, Empty);
  (n < m) -> insert(n, T(t, m, t')) = insert(n, t);
  (n > m) -> insert(n, T(t, m, t')) = insert(n, t');
  (n == m) -> insert(n, T(t, m, t')) = T(t, m, t');
\end{verbatim}

Note here that \texttt{Nat \# Tree} denotes the cartesian product
\texttt{Nat $\times$ Tree} and that the arrows \texttt{(->)} as in
\texttt{(n < m) -> \dots} denote optional boolean guards on the equations.
As with functional programming, there is some support for writing them using
pattern matching.
To evaluate these equations, the toolset treats them as rewriting rules
\cite{mcrl_rewriting}, oriented from left to right.

Next, we define, as processes, a binary search tree and a button which
when pressed, empties the tree:

\begin{verbatim}
act
  insert : Nat;
  press, press_r, press_s;

proc
  Tree(t : Tree) =
    sum n : Nat. (
      insert(n) .
      Tree(insert(n, t))
    )
    + press_r . Tree(Empty);

  Button =
    press_s . Button;
\end{verbatim}

The \texttt{Tree} process is parameterized over a tree \texttt{t}, indicating
the current state of the tree.
It has 2 actions, namely \texttt{insert(n)} which inserts \texttt{n} into the
tree and \texttt{press\_r}, which receives (hence the \texttt{\_r}) a button
press.
These are composed together using the (nondeterministic) choice operator
\texttt{+} so that the
tree may either have something inserted into it or receive a button press at
each step.
The button then has a corresponding \texttt{press\_s} which sends
(hence the \texttt{\_s}) such a press to the tree.
Briefly, \texttt{sum n : Nat. \dots} is used to indicate a
choice over all possible natural numbers, so that any natural number can be
inserted into the tree.
Also note that we use tail recursion to update the internal state of the tree,
as is common in functional programming.

Finally, we can define the initial process as a parallel composition
(\texttt{$\cdot$ || $\cdot$}) of the \texttt{Tree} process, beginning with an
empty tree and the button, \texttt{Button}.

\begin{verbatim}
init
  allow({insert, press},
  comm({press_r|press_s -> press},
  Tree(Empty) || Button));
\end{verbatim}

Since we only want the tree to empty itself when the button is pressed, and
not at any other times, we use \texttt{allow} and \texttt{comm}(unicate) to
enforce communication.
Simply put, this means that the \texttt{press\_s} and \texttt{press\_r} in both
processes must be executed together in the same atomic step.
Here, \texttt{press\_r|press\_s} is a \textit{multi-action} which is an atomic
action representing the simultaneous execution of both the individual actions.

One can then use the tools provided by the \mcrl \, toolset to automatically
transform this specification into a LTS.
Note that the resulting transition system contains infinitely many states as
each $\mathtt{n} \in \N$ gives rise to a transition labelled \texttt{insert(n)}.
Thus, we see that the \mcrl \, toolset provides us with a convenient, high level
formalism with which we can concisely express large (infinite in this case)
transition systems.

\subsection{Formalizing the contract in mcrl2}
As we wanted our specification to be modular, we began by defining the
following global constants and functions over which the rest of our
specification is parameterized.

\begin{verbatim}
map
  % The total number of payments involved in the contract.
  total_num_payments : Pos;

  % payment_amt(n) is the amount the borrower has to pay for payment n.
  payment_amt : Pos -> Pos;

  % The principal amount the lender sends the borrower.
  principal_amt : Pos;

  % The initial amount that the borrower owes the lender.
  initial_outstanding_amt : Pos;

var n : Pos;

eqn
  total_num_payments = 2;
  principal_amt = 1000;
  initial_outstanding_amt = 1075;

  (n == 1) -> payment_amt(n) = 550;
  (n == 2) -> payment_amt(n) = 525;
\end{verbatim}

% As aforementioned, the \mcrl \, specification language operates at a higher
% level of abstraction than LTSes, so that
% we do not need to ``hard code'' the values of these variables like in the
% original DFA encoding in \cite{contract_as_automaton}.
These can be easily changed for instance to
account for additional payment stages, or to incorporate interest rate
calculations into \texttt{payment\_amt}.
We only require that:

\begin{enumerate}
  \item
  \texttt{payment\_amt} is a partial function defined on the domain:
  \begin{align*}
    \dom \text{payment\_amt} = \set{n \in \N}{n \leq \text{total\_num\_payments}}
  \end{align*}

  \item
  The sum of all payment amounts is equal to the initial outstanding amount,
  that is:
  \begin{align*}
    \sum_{n \in \dom \text{payment\_amt}}
      \text{payment\_amt}(n) = \text{initial\_outstanding\_amt}
  \end{align*}
\end{enumerate}

As the rest of our specification makes no further assumptions about the values
of these constants and the computation performed in \texttt{payment\_amt},
changing these do not require any further changes in the structure of the 
specification.
In comparison, if one were to add additional payment stages to the DFA in
\cite{contract_as_automaton} directly, one will need to manually alter the
structure of the DFA by introducing more states and transitions.
This highlights one advantage of our approach.

To proceed with our formalization, we observed that the contract has 4 key
stages, which we can model as processes in \mcrl.
\inlinetodo{
  Mention modeling real world events as atomic actions.
}
These stages are:

\begin{enumerate}
  \item \textbf{Initialization}
  
  The contract begins in this stage, where the borrower may
  request for the principal amount.
  Upon such a request, the lender is obliged to send it.
  Thereafter, the process starts the main and side tracks below simultaneously,
  before terminating.

  \item \textbf{Main repay payments track}

  This process handles all the payments that the borrower makes to the lender.
  Once these are completed, the side track process is
  terminated and the contract as a whole is fulfilled.
  Should the borrower default on a payment, the accelerated repayment process
  is started.

  \item \textbf{Side borrower default track}

  This process waits for the occurrence of a borrower default event and starts
  the accelerated repayment process should the borrower fail to cure the
  default.

  \item \textbf{Accelerated repayment}

  As described above, this is triggered when things go wrong.
  Once started, it terminates both the main and side track processes and then
  handles the accelerated repayment stage, in which the borrower is obliged to
  repay the outstanding amount immediately.
\end{enumerate}

\inlinetodo{
  Draw and insert picture.
}

The initialization phase of the contract is modelled by the following
\texttt{Init} process:

\begin{verbatim}
Init =
  dont_request_principal . fulfilled
  + request_principal . (
      payment_default(Principal, Lender, Borrower, principal_amt) .
      breached
      + pay(Principal, Lender, Borrower, principal_amt) .
        start_main_s . start_side_s
    );
\end{verbatim}

At the start of the contract, the borrower has the option of requesting for
the principal amount.
When that happens,

\info{
  Some notes:

  Talk about how the main repayment track is recursive, modelling a loop that
  iterates through the number of payments involved in the loan agreement.

  While \mcrl \, does not have a notion of global variables like other formalisms
  (mention other formalisms here, maybe uppaal?), these can be easily
  simulated.
  Our specification defines ``global variables'' representing the current
  runtime state of the contract, namely the remaining number of payments as well
  as the outstanding amount.
  These variables are then updated whenever a normal repayment event occurs, and
  referenced during accelerated repayment event.

  % using the technique described in \cite[Section 3.2.2]{mcrl_lhc}.

  Finally, our formalization also allow for more events to be interleaved
  concurrently.
  In particular, we make no assumption that the borrower is notified immediately
  after a default event occurs.
  Payment events or even other default events may occur in the meantime, so that
  in the latter case, the borrower has multiple defaults to cure.
}

\subsection{Visualization and simulation}

\subsection{Background on the modal mu calculus in mcrl2}

\subsection{Automated reasoning with the contract}

\section{Related work}

\section{Limitations and future work}

\begin{enumerate}
  \item No explicit notion of real time, ie no global clock process.

  \item We don't keep track of blame assignment, ie who is in breach of the
  contract.

  \item Lack of native notion of process interruption, and inability of
  linearizer to handle parallel composition under sequential comp and recursion,
  ie \texttt{A . (B || C)}, makes modelling a bit inconvenient and unnatural.

  \item Squeezing out deontics completely means we have no way to really reason
  about obligations and permissions.

  Explore Guido's work on why deontics cannot be adequately represented in
  temporal logics, LTL in particular.

  Eg: if we take
  \begin{enumerate}
    \item Maintenance obligation $\Rightarrow$ Always
    \item Achievement obligation $\Rightarrow$ Eventually
  \end{enumerate}
  then how to handle permission?

  Also, how to handle reparation/compensation?
\end{enumerate}

% which make such an encoding cumbersome.

% For instance, there is a verbose duplication of states along the main
% ``happy path'' in \cite[Fig. 1]{contract_as_automaton}.
% Note here that when we say ``duplication'', we do not mean that there are states
% which play exactly the same role from the point of view of language acceptance,
% as in the sense of the Myhill-Nerode technique of DFA minimization.
% What we mean instead is that there are similarly named states whose subgraphs
% have similar structure.


% Beneath these, there are similarly named states representing the occurrence of a
% borrower default event, which in turn lead to payment accelerating states,
% lying along the unhappy paths.
% Here, one sees that the duplicated states lying along the happy path also gives
% rise to a duplication in states along the unhappy paths.

% ``borrower defaults on representations/warranties'' and ``payment made''.

\newpage

% Bibliography stuff.
\bibliographystyle{acm}
\bibliography{refs}

\end{document}