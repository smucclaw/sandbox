#+LATEX_HEADER: \usepackage{lineno}
#+OPTIONS: toc:nil

* homework 1 by mwwong@smu.edu.sg

** Exercise 1

#+begin_quote
Conceptual question: In the latter example, how could we change the
code without altering the final postcondition? How does the
“forgetting” of assertions correspond to a form of modularity?
#+end_quote

Answer: we could say:

#+begin_src
  z = x ;
#+end_src

Or we could say:

#+begin_src
  z = y ;
#+end_src

The modularity consists of only caring about certain aspects of the software; if we are certain that both x and y are sufficient conditions for z, we are comfortable discarding one or the other.

If in practice x and y are asynchronous results from some API call against remote servers, we can proceed with the first to return, not needing both.

This reminds me of how we could approximate Boolean $\top\ \lor \perp$ with $1+0$.

** Comment

#+begin_quote
So, in order to get a canonical weakest precondition, we need both the
code and a postcondition. In order to get a canonical strongest
postcondition, we need both the code and a precondition. We cannot get
something logical without already having something logical.
#+end_quote

If we use the following definitions of deductive, abductive, and
inductive reasoning:

| facts    | rules    | outcome  | reasoning |
|----------+----------+----------+-----------|
| /sought/ | input    | input    | abductive |
| input    | /sought/ | input    | inductive |
| input    | input    | /sought/ | deductive |

Abductive reasoning goes from rules and outcomes to facts that satisfy.

Inductive reasoning goes from facts and outcomes to guess at rules.

Deductive reasoning goes from facts and rules to conclude outcomes.

We see a similar logic at work, substituting

| facts        | rules | outcome       |
|--------------+-------+---------------|
| precondition | code  | postcondition |


** Exercise 2

1. { $a = 0$ }
2. $b := 2 - a$
3. { $b = 2$ }
4. $c := b * 2$
5. { $c = 4$ }
6. $d := c + 1$
7. { $d = 5$ }

** Exercise 3

1. { $x \in \mathbb{N}$ }
2. $y := (x / 2) * 2$
3. { ($x$ odd $\Rightarrow$ $y = x - 1$) $\land$ ($x$ even $\Rightarrow$ $y = x$)  }
4. $z := x - y$
5. { ($x$ odd $\Rightarrow$ $z = 1$) $\land$ ($x$ even $\Rightarrow$ $z = 0$)  }
6. $a := z * 5 + (1 - z) * 12$
7. given

** Exercise 4

1. { true }
2. $d := (2-(a+1)/a)/2$
3. { $( a <= 0 \Rightarrow d = 1) \land ( a > 0 \Rightarrow d = 0 )$ }
4. m := d * 2 + (1-d) * 3
5. { $( a <= 0 \Rightarrow m = 2) \land ( a > 0 \Rightarrow m = 3 ) \land b \in \mathbb{Z}$ }
6. x := b * 2
7. { $( a <= 0 \Rightarrow m = 2) \land ( a > 0 \Rightarrow m = 3 ) \land (x = b * 2)$ }
8. x := x * 2
9. { $( a <= 0 \Rightarrow m = 2) \land ( a > 0 \Rightarrow m = 3 ) \land x = b * 4$ }
10. x := m * x
11. { $( a <= 0 \Rightarrow x = 8*b) \land ( a > 0 \Rightarrow x = 12*b)$ }
12. x := x + 1
13. given
   
** Comment on 4.4

This is [[https://en.wikipedia.org/wiki/Robustness_principle][Postel's law]]! "be conservative in what you send, be liberal in what you accept"

** Exercise 5

We move the simpler business with the $x$ up above the complicated business with the $a$, $d$, and $m$.

1. { true }
2. x := b * 2
3. { $x = b * 2$ }
4. x := x * 2
5. { $x = b * 4$ }
6. x := x + 1
7. { $x = b * 4 + 1$ }
8. $d := (2-(a+1)/a)/2$
9. { $x = b * 4 + 1 \land ( a <= 0 \Rightarrow d = 1) \land ( a > 0 \Rightarrow d = 0 )$ }
10. m := d * 2 + (1-d) * 3
11. { $x = b * 4 + 1 \land ( a <= 0 \Rightarrow m = 2) \land ( a > 0 \Rightarrow m = 3 )$  }
12. x := m * x
13. given

** Exercise 6

The possibility of concurrency makes me want to explicitly assume that the array is either immutable, or that we are guaranteed that no other code is going to change the parts of the array < i while we are in the loop.

The loop invariant: given an array with $n$ slots, $i <= n$, and at the start of iteration $i$ of the loop, the desired $val$ is not found in the slots below $i$

